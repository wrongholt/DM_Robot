/*
// fuzzy-responses module: a helper module to pick a fuzzy response from an actual response
*/

import { escapeRegExp } from './utilities';

type ResponseScore = {
    match: number,
    ratio: number
};

type ResponseScores = {
    [key: string] : ResponseScore
};

// Pick best response from the given list of strings, if key is provided, instead of a list of strings you can pass a list
// of objects and the item inside of the object named key will be used for the text match.
export function pickBestResponse(actualResponse: string, fuzzyResponses: string[], key?: any): {
    index: number,
    response: string | null
} | undefined
 {
    let fuzzyResponseScores: ResponseScores = {};

    if(!actualResponse) {
        actualResponse = "";
    }

    fuzzyResponses.forEach(function(fuzzyResponse: any) {

        let fuzzyResponseComparisonVal = fuzzyResponse;

        if(key) {
            fuzzyResponseComparisonVal = fuzzyResponse[key];
        }

        fuzzyResponseScores[fuzzyResponseComparisonVal] = {
            match: 0,
            ratio: 0
        };

        actualResponse.split(" ").forEach(function(item) {
            let regExp = new RegExp('(^|\\s)' + escapeRegExp(item) + '($|\\s)', 'ig');

            while ((regExp.exec(fuzzyResponseComparisonVal)) !== null) {
                fuzzyResponseScores[fuzzyResponseComparisonVal].match += 1;

                // @larpente: Changing so that repeated words in the response string only count for 1 (like for word 'the' for example), by 'break'ing here
                break;
            }
        }); 

        fuzzyResponseScores[fuzzyResponseComparisonVal].ratio = fuzzyResponseScores[fuzzyResponseComparisonVal].match/fuzzyResponseComparisonVal.split(" ").length;
    });

    let fuzzyResponseMax: string | null = null;
    let fuzzyResponseMaxScore = {
        match: 0,
        ratio: 0
    };

    for (const fuzzyResponse in fuzzyResponseScores) {

        let fuzzyResponseScore = fuzzyResponseScores[fuzzyResponse];

        if (fuzzyResponseScore.match >= fuzzyResponseMaxScore.match && fuzzyResponseScore.ratio >= fuzzyResponseMaxScore.ratio) {
            fuzzyResponseMax = fuzzyResponse;
            fuzzyResponseMaxScore = fuzzyResponseScore;
        }
    }

    let matchedIndex = -1;
    let matchedItem: string | null = null;
    if(!key) {
        matchedIndex = fuzzyResponses.indexOf(fuzzyResponseMax || '');
        matchedItem = fuzzyResponseMax;
    } else {
        for(let i = 0; i < fuzzyResponses.length; i++) {
            let resp = fuzzyResponses[i];

            let content = resp[key];
            if(fuzzyResponseMax === content) {
                matchedIndex = i;
                matchedItem = resp;
                break;
            }
        }        
    }
    
    if (fuzzyResponseMaxScore.match > 0) {
        return {
            index: matchedIndex,
            response: matchedItem
        };
    } else {
        return undefined;
    }
}

export function pickFuzzyResponse(actualResponse: string, fuzzyResponses: string[]): string | null {
    let fuzzyResponseScores: { [key: string]: number} = {};

    fuzzyResponses.forEach(function(fuzzyResponse: string) {
        let regExp = new RegExp('(^|\\s)' + escapeRegExp(fuzzyResponse) + '($|\\s)', 'ig');
        let results = null;

        while ((results = regExp.exec(actualResponse)) !== null) {
            fuzzyResponseScores[fuzzyResponse] = results.index;
        }
    });

    let fuzzyResponseMax = null;
    let fuzzyResponseMaxScore = null;

    for (const fuzzyResponse in fuzzyResponseScores) {
        let fuzzyResponseScore = fuzzyResponseScores[fuzzyResponse];

        if (fuzzyResponseMaxScore === null || fuzzyResponseScore > fuzzyResponseMaxScore) {
            fuzzyResponseMax = fuzzyResponse;
            fuzzyResponseMaxScore = fuzzyResponseScore;
        }
    }

    return fuzzyResponseMax;
}
