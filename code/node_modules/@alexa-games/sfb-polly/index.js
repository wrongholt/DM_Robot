// Alexa-Polly Module, for easily embedding Polly voice tags in your Alexa responses and converting them with Polly

// 
// DONE 10/21: 1. Add flag to append as many files together as possible to reduce overall audio tag count

const async = require('async');

var crypto = require('crypto');

const Fs = require('fs');

const AWS = require('aws-sdk');

const mp3Duration = require('mp3-duration');

const Path = require('path');

// A cache of URLs to their duration time in ms, so that mp3-duration does not need to be called again for these urls
let mp3DurationCache = {};

// A cache of polly text strings to their duration time in ms, so polly does not need to be called again for the given text
let pollyDurationCache = {};

var s3 = new AWS.S3();

var exec = require('child_process').exec;

var S3_DOMAIN_NAME = "s3.amazonaws.com";
var BUCKET_NAME = "alexa-ml";
var WORKING_DIR = "/tmp";
var USE_FFMPEG = true;
var FFMPEG_LOCATION = "./ffmpeg";
var WINDOWS_OS = false;
var FFMPEG_BIN_NAME = "ffmpeg";
var AWS_PROFILE_NAME = "";

var COMBINE_AUDIO_TAGS = false;

var DONT_COMBINE_IF_AUDIO_TAG_SEPERATED_BY_SPACE = true;

var DONT_USE_CACHE = false;

var DONT_UPLOAD_TO_S3 = false;

var VOICE_TAG_AUTO_BREAK = false;
var COGNITO_CONFIG = {};

var registeredVoiceNames = {};

const audioTagRegExp = new RegExp("<audio src=.*? \/>", 'g');	// First look for any audio tags that may be included, and remove them and estimate their lengths seperatly.

var Polly = new AWS.Polly({
    signatureVersion: 'v4',
    region: 'us-east-1'
})

// Types of sequence items
const SEQUENCE_TYPES = {
    MUSIC: 'MUSIC',
    SFX: 'SFX',
	POLLY: 'POLLY'
};

// Must call configure with your own skill's information so that it can use your own S3 bucket.
exports.configureOptions = function configureOptions(options) {

	if('s3DomainName' in options) {
		S3_DOMAIN_NAME = options['s3DomainName'];
	}
	if('bucketName' in options) {
		BUCKET_NAME = options['bucketName'];
	}
	if('workingDir' in options) {
		WORKING_DIR = options['workingDir'];
	}
	if('useFFMPEG' in options) {
		USE_FFMPEG = options['useFFMPEG'];
	}
	if('FFMPEGLocation' in options) {
		FFMPEG_LOCATION = options['FFMPEGLocation'];
	}
	if('windowsOS' in options) {
		WINDOWS_OS = options['windowsOS'];
	}
	if('combineAudioTags' in options) {
		COMBINE_AUDIO_TAGS = options['combineAudioTags'];
	}
	if('dontUseCache' in options) {
		DONT_USE_CACHE = options['dontUseCache'];
	}
	if('ffmpegBinName' in options) {
		FFMPEG_BIN_NAME = options['ffmpegBinName'];
	}
	if('dontCombineIfAudioTagSeperatedBySpace' in options) {
		DONT_COMBINE_IF_AUDIO_TAG_SEPERATED_BY_SPACE = options['dontCombineIfAudioTagSeperatedBySpace'];
	}
	if('dontUploadToS3' in options) {
		DONT_UPLOAD_TO_S3 = options['dontUploadToS3'];
	}
	if('awsProfileName' in options) {
		if(AWS_PROFILE_NAME !== options['awsProfileName']) {
			AWS_PROFILE_NAME = options['awsProfileName'];

			// Setup credentials immediatly if passed in.
			var credentials = new AWS.SharedIniFileCredentials({profile: AWS_PROFILE_NAME});
			AWS.config.credentials = credentials;
	
			// And recreate things created by AWS
			s3 = new AWS.S3();
	
			Polly = new AWS.Polly({
				signatureVersion: 'v4',
				region: 'us-east-1'
			});
		}	
	}
	if('cognito' in options) {

		if(COGNITO_CONFIG.identityPoolId !== options.cognito.identityPoolId && 
			COGNITO_CONFIG.loginWithAmazonAccessToken !== options.cognito.loginWithAmazonAccessToken) {

			COGNITO_CONFIG = options.cognito;

			const { identityPoolId, loginWithAmazonAccessToken } = options.cognito;

			// Initialize the Amazon Cognito credentials provider
			AWS.config.region = 'us-east-1'; // Region

			let cognitoOptions = {IdentityPoolId: identityPoolId};

			if(loginWithAmazonAccessToken) {
				cognitoOptions.Logins = {
					'www.amazon.com': loginWithAmazonAccessToken
				};		
			}

			AWS.config.credentials = new AWS.CognitoIdentityCredentials(cognitoOptions);
			
			// And recreate things created by AWS
			s3 = new AWS.S3();

			Polly = new AWS.Polly({
				signatureVersion: 'v4',
				region: 'us-east-1'
			});
		}
	}
	
	setupAndChmodFFMPEGBinarySync();
}

function setupAndChmodFFMPEGBinarySync() {
	if(!Fs.existsSync(FFMPEG_LOCATION)) {
		return;
	}

	if(!Fs.existsSync(WORKING_DIR)) {
		Fs.mkdirSync(WORKING_DIR);
	}

	// If still does not exist, just return
	if(!Fs.existsSync(WORKING_DIR)) {
		return;
    }
    
    const destPath = Path.join(WORKING_DIR, FFMPEG_BIN_NAME);
    if (Fs.existsSync(destPath)) {
        // ffmpeg already in target location
        return;
    }

	// Adding try catch to avoid crashing the editor when repeatedly called (race condition)
	try {
		Fs.copyFileSync(FFMPEG_LOCATION, destPath);

		Fs.chmodSync(destPath, '0700');
	} catch (e) {
		console.log(e);
	}	

	return;
}

exports.configure = function configure(a_bucketName, a_workingDir, a_useFFMPEG, a_FFMPEGLocation, a_windowsOS, a_combineAudioTags) {

	BUCKET_NAME = a_bucketName;
	WORKING_DIR = a_workingDir;
	USE_FFMPEG = a_useFFMPEG;
	FFMPEG_LOCATION = a_FFMPEGLocation;
	WINDOWS_OS = a_windowsOS;
	COMBINE_AUDIO_TAGS = a_combineAudioTags;
	
	// TODO: Possible race condition here. Also, this if might be wrong but leaving as is because maybe it prevents a bug.
	if(combineAudioTags) {
		setupAndChmodFFMPEGBinarySync();
	}
}

exports.enableVoiceTagAutoBreak = function enableVoiceTagAutoBreak() {
    // This fixes an issue where voices are being cut off right at the end of the audio
    VOICE_TAG_AUTO_BREAK = true;
}

exports.registerVoiceName = function registerVoiceName(voiceName, params) {
	// Handle "zero" case, means you can't use ZERO as an actual key
	if(voiceName == 0) {
		voiceName = "ZERO";
	}

	registeredVoiceNames[voiceName] = params; // No params checking right now, needs to be parameters needed to build voice tag
}

exports.wrapWithVoiceTag = function wrapWithVoiceTag(voiceName, content, music, trim) {
	// Handle "zero" case, means you can't use ZERO as an actual key
	if(voiceName == 0) {
		voiceName = "ZERO";
	}

	if(!voiceName) {
		return content;
	}

	var voiceStart = "";
	var voiceEnd = "";

	if(voiceName != "Alexa") {
		voiceStart = "<voice name='" + voiceName + "'";

		if(music) {
			voiceStart += " music='" + music + "'";
		}

		// Need to use music flag if using the trim flag
		if(music && trim) {
			voiceStart += " trim='" + trim + "'";
		}

		voiceStart += ">";

		voiceEnd = "</voice>";
	}


	var contentWithTags = '';

	// Need to split content on <audio tags, because they are not allowed within a polly request, also need to handle voice tags and leave them as is
	var contentParts = content.split("<audio ");

	if(contentParts) {
		for(var i = 0; i < contentParts.length; i++) {
			var part = contentParts[i];
			var audioTag = '';

			// Re-add "<audio" if not the first item on the list
			if(i > 0) {
				part = "<audio " + part;

				// Also remove the whole audio tag, looking for it's closing /> sign
				var audioTagLength = part.indexOf("/>") + 2;

				audioTag = part.substr(0, audioTagLength); // Grad the first part with the audio tag
				part = part.substring(audioTagLength); // Grab the second part with the rest of the content
			}

			contentWithTags += audioTag;

			// Now check to see if "part" already has a voice tag in it, and if so leave it in there as is
			if(part && part.length > 0) {
				var voiceParts = part.split("<voice ");

				for(var j = 0; j < voiceParts.length; j++) {

					var chunk = voiceParts[j];
					var voiceTagContents = '';

					if(j > 0) {
						chunk = "<voice " + chunk;

						// Now remove the whole voice tag and keep it as is
						var voiceTagLength = chunk.indexOf("</voice>") + 8;

						voiceTagContents = chunk.substr(0, voiceTagLength); // Grad the first part with the audio tag
						chunk = chunk.substring(voiceTagLength); // Grab the second part with the rest of the content
					}

					contentWithTags += voiceTagContents + voiceStart + chunk + voiceEnd;
				}
			}
		}
	}	

	return contentWithTags;
}

function clearEmptyVoiceTags(sourceText) {
	let convertedString = sourceText;

	let emptyTagRegex = /<voice name=["'][^"']*?["'](?: music=["'](.*?)["'])?(?: trim=["'](.*?)["'])?>[\s]*?<\/voice>/g;

	if (convertedString) {
		convertedString = convertedString.replace(emptyTagRegex, "");
	}
	
	return convertedString;
}

exports.convertStringsThroughPolly = function convertStringsThroughPolly(string1Pre, string2Pre, callbackFunc) {
	console.log("Converting Source String 1: " + string1Pre);
	console.log("Converting Source String 2: " + string2Pre);

	let string1 = clearEmptyVoiceTags(string1Pre);
	let string2 = clearEmptyVoiceTags(string2Pre);
	console.log("Clearing empty voice tags String 1: " + string1);
	console.log("Clearing empty voice tags String 1: " + string2);

	var voiceTags1 = parseVoiceTags(string1);
	var convertedString1 = convertStringVoiceTagsToAudioTags(voiceTags1, string1);

	var voiceTags2 = parseVoiceTags(string2);
	var convertedString2 = convertStringVoiceTagsToAudioTags(voiceTags2, string2);
	
	var thisVariable = this;

	async.parallel([
		// Now do all the polly calls and substitutions
		function(callback){	
			callPollyForAllVoiceTags(callback, voiceTags1);
		},		
		function(callback){	
			callPollyForAllVoiceTags(callback, voiceTags2);
		},		
	], function (err,result) {

		if(COMBINE_AUDIO_TAGS && hasMoreThanFiveAudioTags(convertedString1)) {
			console.log("BEFORE:" + convertedString1);
			combineAudioTags(convertedString1, function(combinedString1) {
				console.log("AFTER:" + combinedString1);
				
				callbackFunc.call(thisVariable, combinedString1, convertedString2);

			});
		} else {
			callbackFunc.call(thisVariable, convertedString1, convertedString2);			
		}

	});				
}

function hasMoreThanFiveAudioTags(convertedString) {
	let individualAudioTagRegex = /(<audio [^>)]*?\/>)/g;
	let audioTags = convertedString.match(individualAudioTagRegex);
	return audioTags && audioTags.length > 5
}
exports.hasMoreThanFiveAudioTags = hasMoreThanFiveAudioTags;

exports.emitAskThroughPolly = function emitAskThroughPolly(thisParam, speechOutput, repromptText) {
	
	var voiceTags = parseVoiceTags(speechOutput);
	var convertedSpeechOutput = convertStringVoiceTagsToAudioTags(voiceTags, speechOutput);

	var voiceTagsRepromptText = parseVoiceTags(repromptText);
	var convertedRepromptText = convertStringVoiceTagsToAudioTags(voiceTagsRepromptText, repromptText);
	
	var alexaFunction = thisParam;
	
	async.series([
		// Now do all the polly calls and substitutions
		function(callback){	
			console.log("Calling Polly");
			callPollyForAllVoiceTags(callback, voiceTags);
		},		
	], function (err,result) {
		alexaFunction.emit(':ask', convertedSpeechOutput, convertedRepromptText);
	});
}

exports.emitAskThroughPolly = function emitTellThroughPolly(thisParam, speechOutput) {
	
	var voiceTags = parseVoiceTags(speechOutput);
	var convertedSpeechOutput = convertStringVoiceTagsToAudioTags(voiceTags, speechOutput);

	console.log("Converted Speech Output: " + convertedSpeechOutput);
	
	var alexaFunction = thisParam;
	
	async.series([
		// Now do all the polly calls and substitutions
		function(callback){	
			console.log("Calling Polly");
			callPollyForAllVoiceTags(callback, voiceTags);
		},		
	], function (err,result) {
		console.log("Converted Speech Output: " + convertedSpeechOutput);
		alexaFunction.emit(':tell', convertedSpeechOutput);
	});
}

// Find all of the voice tags in a string to call polly for, remove the text, then substitute back in the mp3 file
function parseVoiceTags(sourceText) {
	
	var regexHighLevel = /<voice name=["'].*?["'](?: music=["'](.*?)["'])?(?: trim=["'](.*?)["'])?>[\s\S]*?<\/voice>/g;
	var regex = /<voice name=["'](.*?)["'](?: music=["'](.*?)["'])?(?: trim=["'](.*?)["'])?>([\s\S]*?)<\/voice>/;

	// Hold our return argument
	var voiceTags = [];

	if(!sourceText) {
		return voiceTags;
	}
	
	var matchesHighLevel = sourceText.match(regexHighLevel);
	
	if(matchesHighLevel) {
		console.log("Voice Tag Num Matches: " + matchesHighLevel.length);
		for(var i = 0; i < matchesHighLevel.length; i++) {

			var matches = matchesHighLevel[i].match(regex);

			if(matches.length >= 3) {
				var fullMatch = matchesHighLevel[i];
				var name = matches[1];
				var content = matches[2];
				var music = undefined;
				var trim = undefined;

				if(matches.length >= 4) {
					music = matches[2];
					content = matches[3];
				}
				if(matches.length >= 5) {
					music = matches[2];
					trim = matches[3];
					content = matches[4];
				}
                
                // console.log("Found Polly Voice for: " + name + " with content: " + content);
                
                // If using register voice functionality, automatically wrap text in a prosody tag
                let prosodyTagNeeded = addProsodyTagIfNeeded(name, content);

                if (prosodyTagNeeded) {
                    console.log(prosodyTagNeeded);
                    name = prosodyTagNeeded.pollyName;
                    content = prosodyTagNeeded.wrappedText;
                }

                if (VOICE_TAG_AUTO_BREAK) {
                    content += '<break time=\'0.5s\'/>';
                }
				
				var voiceTag = {};
				voiceTag["fullMatch"] = fullMatch;
				voiceTag["name"] = name;
				voiceTag["content"] = content;
				voiceTag["music"] = music;
				voiceTag["trim"] = trim;
								
				var stringToEncode = JSON.stringify(voiceTag);
				var md5hash = crypto.createHash('md5').update(stringToEncode).digest('hex');	
				voiceTag["md5hash"] = md5hash;
				
				voiceTags[voiceTags.length] = voiceTag;
			}
		}
	}
	
	//console.log(voiceTags);
	return voiceTags;
}

function callPollyForVoiceTag(callback, voiceTag, outputFileIndex) {

	var mp3OutputFilename = voiceTag.md5hash;
	
	// Check S3 to see if this file already exists
	var params = {
		Bucket: BUCKET_NAME, 
		Key: "tempPolly/" + mp3OutputFilename + ".mp3"
	};

	if(DONT_USE_CACHE) {
		convertStringsWithPolly(callback, voiceTag.name, voiceTag.content, voiceTag.music, voiceTag.trim, mp3OutputFilename);
	} else {

		s3.headObject(params, function(err, data) {
			if (err) {
				// If an error occurred, then the item didn't likely exist in S3, so call polly to create it
				convertStringsWithPolly(callback, voiceTag.name, voiceTag.content, voiceTag.music, voiceTag.trim, mp3OutputFilename);
			} else {
				callback();
			}
		});
	}
}

function convertStringVoiceTagsToAudioTags(voiceTags, sourceString) {
	
	var convertedString = sourceString;
	
	for(var i = 0; i < voiceTags.length; i++) {
		var voiceTag = voiceTags[i];

		convertedString = convertedString.replace(voiceTag.fullMatch, "<audio src='https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/tempPolly/" + voiceTag.md5hash + ".mp3' />");
	}

	return convertedString;
}

function callPollyForAllVoiceTags(callback, voiceTags) {

	var outputFileIndex = 0;
	
	async.each(voiceTags, function (voiceTag, seriesCallback) {
		callPollyForVoiceTag(seriesCallback, voiceTag, outputFileIndex);
		outputFileIndex++;
	}, function () { callback() } );
}

function saveFileToS3AndCallback(filepathOnDisk, checksum, callback) {

	if(DONT_UPLOAD_TO_S3) {
		callback();
		return;
	}
	
	console.log("start read file");
	// Read in the file, convert it to base64, store to S3
	Fs.readFile(filepathOnDisk, function (err, data) {
	  if (err) { throw err; }
	
	  console.log("Start data buffering.");
	  var base64data = new Buffer(data, 'binary');

	  console.log("Start put object to S3");
	  s3.putObject({
		Bucket: BUCKET_NAME,
		Key: 'tempPolly/' + checksum + '.mp3',
		Body: base64data,
		ACL: 'public-read'
	  },function (err, data) {
		console.log(arguments);
		console.log('Successfully uploaded package.');
		callback();
	  });
	  
	});

}

// Call Polly with the necessary strings, convert mp3s to Alexa compatible format, then upload to S3
function convertStringsWithPolly (callback, speakerName, stringToConvert, backgroundMusicFilename, trimSetting, outputFileName) {

	stringToConvert = "<speak>" + stringToConvert + "</speak>";
	
	var pollyParams = {
		'Text': stringToConvert,
		'TextType': 'ssml', 
		'OutputFormat': 'mp3',
		'VoiceId': speakerName,
		'SampleRate': '24000', 
    }
    	
	Polly.synthesizeSpeech(pollyParams, (err, data) => {
	
	console.log("Calling polly with speaker " + speakerName + " and content '" + stringToConvert + "' and output filename " + outputFileName);
	
	if (err) {
		console.log("Error: " + err)
	} else if (data) {
		if (data.AudioStream instanceof Buffer) {
			var pollyFilename = Path.join(WORKING_DIR, "polly" + outputFileName + ".mp3");
			Fs.writeFile(pollyFilename, data.AudioStream, function(err) {
				if (err) {
					return console.log("error writing audio stream: " + err)
				}

				if(!USE_FFMPEG) {
					
					saveFileToS3AndCallback(pollyFilename, outputFileName, callback);
				
				} else {

					// Do a bunch of shenanigans to use ffmpeg
					setupAndChmodFFMPEGBinarySync();

					var volumeChangeFilename = Path.join(WORKING_DIR, outputFileName + '.mp3');
								  
					var cmd = '"' + Path.join(WORKING_DIR, FFMPEG_BIN_NAME) + '" -y -i "' + pollyFilename + '" -t 240 -ac 2 -codec:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 -af volume=15dB "' + volumeChangeFilename + '"';
					
					console.log("Running cmd: " + cmd);

					exec(cmd, function(error, stdout, stderr) {
						console.log("cmd out: " + stdout);
						console.log("cmd err: " + outputFileName + " " + stderr);

						// If user wants background music, download it and mix it with the output file above
						if(!backgroundMusicFilename) { // Empty string or undefined both count as false
							saveFileToS3AndCallback(volumeChangeFilename, outputFileName, callback);
						} else {

							console.log("Fetching music for: " + backgroundMusicFilename);

							// Convert to s3 key if a full URL
							backgroundMusicFilename = backgroundMusicFilename.replace("https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/", "");

							console.log("Converted to key: " + backgroundMusicFilename);

							var getParams = {Bucket: BUCKET_NAME, Key: backgroundMusicFilename}; 

							var musicTmpFilename = Path.join(WORKING_DIR, 'music' + outputFileName + '.mp3');
							var backgroundMusicFile = Fs.createWriteStream(musicTmpFilename);
							var stream = s3.getObject(getParams).createReadStream().pipe(backgroundMusicFile);
							stream.on('finish', function () {

								var trimCommand = "longest"; // Default to longest of two audio files
								if(trimSetting) {
									trimCommand = trimSetting;
								}

								var postMixFilename = Path.join(WORKING_DIR, outputFileName + '.mp3');
								// Now mix it with the spoken text file
								var mixCmd = '"' + Path.join(WORKING_DIR, FFMPEG_BIN_NAME) + '" -y -i "' + pollyFilename + '" -i "' + musicTmpFilename + '" -filter_complex "[1:0]volume=0.2[a1]; [0:0][a1] amix=inputs=2:duration=' + trimCommand + ':dropout_transition=2,volume=4" -t 240 -ac 2 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "' + postMixFilename + '"';
								
								console.log("Running mixCmd: " + mixCmd)
								exec(mixCmd, function(error, stdout, stderr) {
									console.log(stdout);
									console.log(stderr);
								
									saveFileToS3AndCallback(postMixFilename, outputFileName, callback);
								
								});
							
							});
						}								
					}); 


				}
			})
		}
	}
	})
}

exports.combineAudioTags = combineAudioTags;
function combineAudioTags(speechText, callback) {

	var consecutiveAudioRegex = DONT_COMBINE_IF_AUDIO_TAG_SEPERATED_BY_SPACE ? /(<audio [^>)]*?\/>)+/g : /(<audio [^>)]*?\/>[\s]*)+/g;
	var individualAudioTagRegex = /(<audio [^>)]*?\/>)/g;
	
	var matches = speechText.match(consecutiveAudioRegex);

	if(matches) {
		console.log(matches);

		//	async.eachSeries(fileUrls, fetchFileFromS3, function () {

		async.eachSeries(matches, function(match, callback) {
			var combinedAudioTagsChecksum = crypto.createHash('md5').update(match).digest('hex');
		
			var audioTags = match.match(individualAudioTagRegex);
		
			console.log(audioTags);
		
			if(audioTags && audioTags.length > 1) {
				
				// We have a potential candidate to combine audio tags here
				var fileUrls = [];
				for(var j = 0; j < audioTags.length; j++) {
		
					var audioTag = audioTags[j];
		
					console.log("AUDIO: " + audioTag);
					
					var srcUrlRegex = /src=[\"'](.*?)[\"']/g;					
					
					var srcUrlMatch = srcUrlRegex.exec(audioTag);
		
					if(srcUrlMatch) {
						var srcUrl = srcUrlMatch[1];
						console.log(srcUrl);
						fileUrls.push(srcUrl);	
					}
				}
		
				console.log("File URLS:");
				console.log(fileUrls);
		
				// TODO: Support multiple combines in a single text
				// TODO: Support breaking up into 90s chunks, right now this is delegated to the calling client to do this
		
				// Stop after combining the first set of files
				combineFiles(fileUrls, combinedAudioTagsChecksum, function() {
					console.log("Combined files");
		
					let newAudioFileName = "";

					if(DONT_UPLOAD_TO_S3) {
						var tmpFilename = Path.join(WORKING_DIR, combinedAudioTagsChecksum + ".mp3");
						newAudioFileName = `<audio src='${tmpFilename}' />`;
					} else {
						newAudioFileName = "<audio src='https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/tempPolly/" + combinedAudioTagsChecksum + ".mp3' />"
					}
		
					speechText = speechText.replace(match, newAudioFileName);
					callback();
				});
			} else {
				callback();				
			}			
		}, 
			// When all callbacks done, return speechText
			function() {
			callback(speechText);
		});
	} else {
		callback(speechText);		
	}
}

function fetchFileFromS3(fileUrl, callback) {

	var filename = Path.basename(fileUrl);  //NOTE: You cannot currently merge two files that have the same ending file name after the last /...
	var tmpFilename = Path.join(WORKING_DIR, filename);
	
	Fs.exists(tmpFilename, function(exists) {
		if(exists) {
			console.log("FILE ALREADY EXISTS");
			callback();
		} else {

			console.log("Downloading: " + fileUrl);

			downloadFile(fileUrl, function(response) {

				const tmpFile = Fs.createWriteStream(tmpFilename);

				var stream = response.pipe(tmpFile);
				stream.on('finish', function () {
					console.log(fileUrl);
					callback();
				});
	
			});	
		}
	});
}

function combineFiles(fileUrls, outputFileChecksum, callback) {

	// Check to see if already combined and exists in s3
	checkS3ForObject(outputFileChecksum, function(foundInS3) {

		// Can return early if found in S3
		if(foundInS3) {
			callback();
			return;
		} 

		// If combined file not already found on s3, download all files from s3 and concatenate
		async.each(fileUrls, fetchFileFromS3, function () {
			
			// Ok, now all of the files should be locally available

			var fileNames = [];
			for(var i = 0; i < fileUrls.length; i++) {
				var fileUrl = fileUrls[i];
		
				var filename = Path.basename(fileUrl);
		
				fileNames.push(filename);
			}
		
			var concatFilenamesString = "";
			for(var i = 0; i < fileNames.length; i++) {
				var filename = fileNames[i];
		
				filename = Path.join(WORKING_DIR, filename);

				if(i > 0) {
					concatFilenamesString += "|";
				}
			
				concatFilenamesString += filename;
			}
		
			// Then combine them with ffmpeg
		
			var outputFilename = Path.join(WORKING_DIR, outputFileChecksum + '.mp3');
		
			var combineCmd = '"' + Path.join(WORKING_DIR, FFMPEG_BIN_NAME) + '" -y -i "concat:' + concatFilenamesString + '" -t 240 -ac 2 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "' + outputFilename + '"';
			
			// TODO: Check for the combined file checksum on s3 before doing any of this combining of files

			console.log("Running combine command: " + combineCmd)
			exec(combineCmd, function(error, stdout, stderr) {
				console.log(stdout);
				console.log(stderr);
			
				saveFileToS3AndCallback(outputFilename, outputFileChecksum, callback);		
			});
		});
	});
}

function fetchFileFromS3AndPolly(name, text, callback) {

	let checksum = calcPollyChecksum(name, text);
	console.log("Calculated checksum for Polly Sequence: " + checksum);

	checkS3ForObject(checksum, function(foundInS3){

		if(foundInS3) {
			let fileUrl = "https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/tempPolly/" + checksum + ".mp3";
			fetchFileFromS3(fileUrl, callback);
			return;
		}

		// Otherwise call polly to synthesize speech
		callPollySynthesizeSpeech(name, text, checksum, callback);
		return;
	});
	return;
}

function callPollySynthesizeSpeech(name, text, checksum, callback) {

	// Call the other polly synthesize speech method that takes options
	let options = { name: name,
					text: text,
					checksum: checksum};

	callPollySynthesizeSpeechWithOptions(options, callback);
	return;
}

function callPollySynthesizeSpeechWithOptions(options, callback) {

	let name = options.name;
	let text = options.text;
	let checksum = options.checksum;
	let outputFormat = options.outputFormat || "mp3";
	let speechMarkTypes = options.speechMarkTypes || [];

	let stringToConvert = "<speak>" + text + "</speak>";
	
	var pollyParams = {
		'Text': stringToConvert,
		'TextType': 'ssml', 
		'OutputFormat': outputFormat,
		'VoiceId': name,
		'SampleRate': '24000', 
		'SpeechMarkTypes': speechMarkTypes
	}

	let outputFilename = "tempPolly/" + checksum + ".mp3"
	
	Polly.synthesizeSpeech(pollyParams, (err, data) => {
	
		console.log("Calling polly with speaker " + name + " and content '" + stringToConvert + "' and output filename " + outputFilename);
	
		if (err) {
			console.log("Polly Error: " + err)
			err.pollyError = true;

			// Adding a hook for catching Missing Credentails Error from cognito and say that it is because you are offline
			if(err.message && err.message.includes("Missing credentials in config")) {
				err.message = "Voice Preview Error: Voice Preview will not work in offline mode. Please connect to an Internet connection or disable Voice Preview.";
			} else {
				err.message = "Voice Preview Error: '" + err.message + "' given voice '" + name + "' and text '" + text + "'";
			}

			callback(undefined, err);
			return;
		} else if (data) {
			if (data.AudioStream instanceof Buffer) {

				// If outputFormat is ssml, just return the metadata directly in our callback instead of saving to disk
				if(outputFormat == "json") {
					let speechMarksData = data.AudioStream.toString('utf-8');

					try {
					let jsonSpeechMarksObj = JSON.parse(speechMarksData);
					callback(jsonSpeechMarksObj);
					return;
					} catch (errMsg) {
						callback({});
						return;	
					}

				} else {
					var pollyFilename = Path.join(WORKING_DIR, checksum + ".mp3");
					Fs.writeFile(pollyFilename, data.AudioStream, function(err) {
						if (err) {
							return console.log(err)
						}

						// File is now in local folder, so call our callback
						callback();
						return;
					});
				}
			}
		}
	});
}

function checkS3ForObject(checksum, callback) {

	if(DONT_UPLOAD_TO_S3) {
		let existsOnDisk = Fs.existsSync(Path.join(WORKING_DIR, checksum + ".mp3"));
		callback(existsOnDisk);
		return;
	}

	if(DONT_USE_CACHE) {
		callback(false);
	} else {

		var params = {
			Bucket: BUCKET_NAME, 
			Key: "tempPolly/" + checksum + ".mp3"
		};	

		s3.headObject(params, function(err, data) {
			if (err) {
				callback(false); // File didn't exist
			} else {
				callback(true); // File did exist
			}
		});
	}
}

function constructUrlFromChecksum(checksum) {
	if(DONT_UPLOAD_TO_S3) {
		return Path.join(WORKING_DIR, checksum + ".mp3");
	} else {
		return "https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/tempPolly/" + checksum + ".mp3";
	}
}

function calcPollyChecksum(name, text) {
	var jsonStr = JSON.stringify(name + text);
	let checksum = crypto.createHash('md5').update(jsonStr).digest('hex');
	return checksum;
}

// Map from a registered voice back to a pollyName and a prosody tag
function addProsodyTagIfNeeded(voiceName, text) {

	let returnValue = { pollyName: "", wrappedText: "" };

	let voiceParams = registeredVoiceNames[voiceName];

	if(!voiceParams) {
		return undefined;		
	}

	console.log(voiceParams);

	// Else we found some voice params
	returnValue.pollyName = voiceParams.name;


	let prosodyTag = "";
	let endProsodyTag = "</prosody>";

	if(voiceParams.rate || voiceParams.pitch || voiceParams.volume) {
		prosodyTag = "<prosody";
		if(voiceParams.rate) {
			prosodyTag += " rate='" + voiceParams.rate + "'";
		}
		if(voiceParams.pitch) {
			prosodyTag += " pitch='" + voiceParams.pitch + "'";
        }
        if(voiceParams.volume) {
			prosodyTag += " volume='" + voiceParams.volume + "'";
		}
		prosodyTag += ">";
	}

	let wrappedText = "";

	if(prosodyTag) {
		wrappedText = prosodyTag + text + endProsodyTag;
	} else {
		wrappedText = text;
	}

	returnValue.wrappedText = wrappedText;

	return returnValue;
}

exports.AudioSequence = class AudioSequence {

	constructor(options) {
		this.sequenceType = options.sequenceType;
		this.url = options.url || "";
		this.filename = "";
		this.delayMs = options.delayMs || 1;  // TODO: Making at least 1 filter always run by having a 1ms delay
		this.volume = options.volume || 1.0;
		this.fadeOutTime = options.fadeOutTime || 0;
		this.fadeOutDuration = options.fadeOutDuration || 2;
		this.fadeInDuration = options.fadeInDuration || 0;

		if(this.url) {
			this.filename = Path.basename(this.url);
		}
	}

}

exports.PollyAudioSequence = class PollyAudioSequence extends exports.AudioSequence {
	constructor(options) {
		options['sequenceType'] = SEQUENCE_TYPES.POLLY;
		super(options);
		this.name = options.name || "";
		this.text = options.text || "";

		// Calculate checksum, url, and local filename
		this.checksum = calcPollyChecksum(this.name, this.text);

		if(DONT_UPLOAD_TO_S3) {
			this.url = Path.join(WORKING_DIR, this.checksum + ".mp3");
			this.filename = this.checksum + ".mp3";	
		} else {
			this.url = constructUrlFromChecksum(this.checksum);
			this.filename = Path.basename(this.url);
		}
	}
}

exports.AlexaAudioBuilder = class AlexaAudioBuilder {

	constructor() {
		this.audioSequences = [];
	}

	addMusicSequence(options) {
		if(!options) {
			console.log("Error: Undefined options given to addMusicSequence");
			return;
		}

		options['sequenceType'] = SEQUENCE_TYPES.MUSIC;

		this.audioSequences.push(new exports.AudioSequence(options));
	}

	addSFXSequence(options) {
		if(!options) {
			console.log("Error: Undefined options given to addSFXSequence");
			return;
		}

		options['sequenceType'] = SEQUENCE_TYPES.SFX;

		this.audioSequences.push(new exports.AudioSequence(options));
	}

	// User needs to add their own <prosody>...</prosody> tags inside of the text if they want to module voice speed or pitch
	addPollySequence(options) {
		if(!options) {
			console.log("Error: Undefined options given to addPollySequence");
			return;
		}

		// If using register voice functionality, automatically wrap text in a prosody tag
		let prosodyTagNeeded = addProsodyTagIfNeeded(options.name, options.text);
		if(prosodyTagNeeded) {
			console.log(prosodyTagNeeded);
			options.name = prosodyTagNeeded.pollyName;
			options.text = prosodyTagNeeded.wrappedText;
		}

		this.audioSequences.push(new exports.PollyAudioSequence(options));
	}

	buildAudioFile(callback, handlerContext) {

		var outputUrl = "";

		// Need to include trim setting in the checksum
		var trimCommand = "longest"; // Default to longest of audio files

		if(this.trimSetting) {
			trimCommand = this.trimSetting;
		}

		// Cache and do head request to see if this entire operation is already done
		var jsonStr = JSON.stringify(this.audioSequences) + trimCommand;
		let checksum = crypto.createHash('md5').update(jsonStr).digest('hex');
		console.log("Calculated checksum from all audio sequences: " + checksum);

		let outputFilename = "tempPolly/" + checksum + ".mp3"

		let thisObj = this;

		checkS3ForObject(checksum, function(foundInS3) {

			// Can return early if found in S3
			if(foundInS3) {
				if(handlerContext) {
					callback.call(handlerContext, constructUrlFromChecksum(checksum));
				} else {
					callback(constructUrlFromChecksum(checksum));
				}
				return;
			}

			// Fetch all of the inputs locally
			async.each(thisObj.audioSequences, thisObj.fetchAudioSequenceLocally, function (err) {

				if(err) {
					callback(undefined, err);
				}

				// Now, all the files are locally available on disk, so use ffmpeg to combine them all together

				let ffmpegCommand = '"' + Path.join(WORKING_DIR, FFMPEG_BIN_NAME) + '" -y ';

				let inputFiles = "";
				let streamProcessingList = "";
				let streamList = "";

			
				for(let i = 0; i < thisObj.audioSequences.length; i++) {

					let sequence = thisObj.audioSequences[i];

					// TODO: Figure out how to set offsets for the start of sound files

					inputFiles += ' -i "' + Path.join(WORKING_DIR, sequence.filename) + '" ';

					// Use adelay filter to add a delay to the start of various sounds
					// List this  [1:a] adelay=2500|2500 [delayed];  // 2500 listed for each audio channel

					let volumeFilter = (sequence.volume != 1.0) ? "volume=volume=" + sequence.volume : "";

					let fadeInFilter = (sequence.fadeInDuration) ? "afade=t=in:start_time=0:d=" + sequence.fadeInDuration: "";

					let fadeOutFilter = (sequence.fadeOutTime) ? "afade=t=out:start_time=" + sequence.fadeOutTime + ":d=" + sequence.fadeOutDuration + ",atrim=duration=" + (sequence.fadeOutTime + sequence.fadeOutDuration): "";

					let adelayFilter = (sequence.delayMs) ? "adelay=" + sequence.delayMs + "|" + sequence.delayMs : "";

					let filtersString = "";

					if(fadeInFilter) {
						filtersString += fadeInFilter;
					}
					if(fadeOutFilter) {
						if(filtersString) {
							filtersString += ",";
						}
						filtersString += fadeOutFilter;
					}
					if(adelayFilter) {
						if(filtersString) {
							filtersString += ",";
						}
						filtersString += adelayFilter;
					}
					if(volumeFilter) {
						if(filtersString) {
							filtersString += ",";
						}
						filtersString += volumeFilter;
					}

					streamProcessingList += "[" + i + ":0] " + filtersString + "[in" + i + "]; "; 

					streamList += "[in" + i + "]";
				}

				ffmpegCommand += inputFiles;

				var postMixFilename = Path.join(WORKING_DIR, checksum + '.mp3');

				//[1:0]volume=0.2[a1]; [0:0][a1] amix=inputs=2:duration=' + trimCommand + ':dropout_transition=2,volume=4" -ac 2 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 ' + postMixFilename;
				ffmpegCommand += ' -filter_complex "' + streamProcessingList + " " + streamList + ' amix=inputs=' + thisObj.audioSequences.length + ':duration=' + trimCommand + ':dropout_transition=300,volume=' + thisObj.audioSequences.length  + '" -t 240 -ac 2 -c:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "' + postMixFilename + '"';
				
				console.log("Running ffmpeg command: " + ffmpegCommand)

				exec(ffmpegCommand, function(error, stdout, stderr) {
					console.log(stdout);
					console.log(stderr);
				
					saveFileToS3AndCallback(postMixFilename, checksum, function() {

						let newAudioUrl = "";

						if(DONT_UPLOAD_TO_S3) {
							newAudioUrl = Path.join(WORKING_DIR, checksum + ".mp3");
						} else {
							newAudioUrl = "https://" + S3_DOMAIN_NAME + "/" + BUCKET_NAME + "/tempPolly/" + checksum + ".mp3";
						}	
						
						if(handlerContext) {
							callback.call(handlerContext, newAudioUrl);
						} else {
							callback(newAudioUrl);
						}		
					});
				});
			});
		});			
	}

	// callback doesn't return anything, but is only called once file is on local disk in the configured tmp directory
	fetchAudioSequenceLocally(sequence, callback) {

		// Fetch the files to local disk if not already on disk
		if(sequence.sequenceType == SEQUENCE_TYPES.MUSIC || sequence.sequenceType == SEQUENCE_TYPES.SFX) {
		
			fetchFileFromS3(sequence.url, callback);
			return;
		
		} else if(sequence.sequenceType == SEQUENCE_TYPES.POLLY) {
			// For inputs like Polly voices, call polly to get the input files locally
			fetchFileFromS3AndPolly(sequence.name, sequence.text, function(url, err) {
				callback(err);
			});
			return;
		}				
	}

}

exports.estimateLengthOfAllAudioTags = function estimateLengthOfAllAudioTags(handlerContext, speechSSML, callback) {

	// Now remove all the audio tags, and look up estimates for their length (or query their length using an mp3 duration module)
	let matches = speechSSML.match(audioTagRegExp);

	let duration = 0;

	if(!matches) {
		if(handlerContext) {
			callback.call(handlerContext, duration);
		} else {
			callback(duration);
		}		
		return;
	}

	let audioUrls = [];

	let srcRegEx = new RegExp("src=[\"'](.*?)[\"']");

	for(const match of matches) {
		console.log("Found Audio Tag: " + match);

		let audioUrlMatch = match.match(srcRegEx);

		if(audioUrlMatch) {
			let audioUrl = audioUrlMatch[1];
			console.log(audioUrl);	
			
			audioUrls.push(audioUrl);
		}
	}

	// Fetch all files locally
	async.each(audioUrls, fetchFileFromS3, function () {

		// Ok, all files are now locally available on disk
		async.eachSeries(audioUrls, function (audioUrl, seriesCallback) {

			let filename = Path.basename(audioUrl);
			let relativeFilename = Path.join(WORKING_DIR, filename);
	
			let cachedDuration = mp3DurationCache[audioUrl];
			if(cachedDuration) {
				console.log("Found cached duration of " + cachedDuration);
				duration += cachedDuration;
				seriesCallback();
				return;
			} else {
			// Now estimate the length of all audio urls
			mp3Duration(relativeFilename, function (err, durationForThisFile) {
				if (err) return console.log(err.message);
				console.log('Your file is ' + durationForThisFile + ' seconds long');

					let durationInMs = durationForThisFile * 1000.0; // convert to milliseconds

					// Remember in local cache
					mp3DurationCache[audioUrl] = durationInMs;

					duration += durationInMs; // Add to total duration
				seriesCallback();
				return;
			});
			}

			return;

		}, function () { 
			// Overall callback that returns the duration to our calling function
			if(handlerContext) {
				callback.call(handlerContext, duration);
			  } else {
				callback(duration);
			  }						
		});
		return;
	
	});
	return;	
}

// Add estimate duration of given speech SSML
exports.estimateDurationForSSML = function estimateDurationForSSML(handlerContext, speechSSML, callback) {
	
	exports.estimateLengthOfAllAudioTags(handlerContext, speechSSML, function(audioTagDurationMs) {

		console.log("Total audio tag duration was (in ms): " + audioTagDurationMs);

		// Now remove all audio tags to get a duration of the remaining text spoken by alexa
		speechSSML = speechSSML.replace(audioTagRegExp, " ");

		let voiceToUse = 'Joanna'; // In tests, the Joanna voice takes the same time to read text as Alexa's natural voice does

		// Add a <mark name='the_end'/> tag to the end of the request
		speechSSML = speechSSML.trim();

		if(!speechSSML) {
			// If no real text to convert, then just return with the audio duration
			if(handlerContext) {
				callback.call(handlerContext, audioTagDurationMs);
			} else {
				callback(audioTagDurationMs);
			}
			return;			
		}

		speechSSML += "<mark name='the_end'/>";

		let options = { name: voiceToUse,
						text: speechSSML,
						checksum: "randomChecksum",
						outputFormat: "json",
						speechMarkTypes: ['ssml']
					};

		let pollyDuration = pollyDurationCache[speechSSML];

		if(pollyDuration) {
			console.log("Cached SSML duration is: " + pollyDuration);
	
			let grandTotalDuration = pollyDuration + audioTagDurationMs;

			console.log("Grand total audio duration is: " + grandTotalDuration);

			if(handlerContext) {
				callback.call(handlerContext, grandTotalDuration);
			} else {
				callback(grandTotalDuration);
			}
			return;
		} else {

		callPollySynthesizeSpeechWithOptions(options, function(speechMarks) {
			console.log("Called estimate timing for SSML");

			console.log(speechMarks);

			// Assuming that only mark tag included was the "mark" tag that we added called "the_end"
			let duration = 0;

			if(speechMarks && speechMarks.time) {
				duration = speechMarks.time;
			}

				// TODO: Handle error case whre speechMarks comes back invalid from call to Polly
	
			console.log("Estimated SSML duration is: " + duration);

				// Update our cached value
				pollyDurationCache[speechSSML] = duration;

			let grandTotalDuration = duration + audioTagDurationMs;

			console.log("Grand total audio duration is: " + grandTotalDuration);

			if(handlerContext) {
				callback.call(handlerContext, grandTotalDuration);
			} else {
				callback(grandTotalDuration);
			}
		});
			return;
		}
	});
	return;
}

// Re-encode a given mp3 file into an Alexa friendly mp3 format. Backup bucket is where to store a backup copy to, delete original flag only works when making a backup copy
exports.reencodeMp3 = function reencodeMp3(srcBucket, srcKey, destBucket, destKey, backupBucket, backupKey, deleteOriginal, callback) {

	// URI Decode the key if it had spaces or other symbols in it
//	srcKey = decodeURIComponent(sr.replace(/\+/g, '%20'));
// Problem with local files names if the name has spaces in it, so this is commented out above.

	let fullUrl = "https://" + S3_DOMAIN_NAME + "/" + srcBucket + "/" + srcKey;

	fetchFileFromS3(fullUrl, function() {

		let filename = Path.basename(fullUrl);
		let relativeFilename = Path.join(WORKING_DIR, filename);
		let outputFilename = Path.join(WORKING_DIR, "reencoded" + filename);

		var cmd = '"' + Path.join(WORKING_DIR, FFMPEG_BIN_NAME) + '" -y -i "' + relativeFilename + '" -t 240 -ac 2 -codec:a libmp3lame -b:a 48k -ar 24000 -write_xing 0 "' + outputFilename + '"';
		
		console.log("Running cmd: " + cmd);

		exec(cmd, function(error, stdout, stderr) {
			console.log("cmd out: " + stdout);
			console.log("cmd err: " + outputFilename + " " + stderr);

			// TODO: Do ffmpeg command to convert to right format and normalize audio

			// Write a file back to s3
			Fs.readFile(outputFilename, function (err, data) {
			if (err) { throw err; }
			
			let base64data = new Buffer(data, 'binary');
		
				s3.putObject({
					Bucket: destBucket,
					Key: destKey,
					Body: base64data,
					ACL: 'public-read'
				},function (err, data) {
					console.log(arguments);
					console.log('Successfully uploaded file');

					if(backupBucket && backupKey) {

						// Write the original file back to s3
						Fs.readFile(relativeFilename, function (err, data) {
							if (err) { throw err; }
						
							let base64data = new Buffer(data, 'binary');
					
							// Unencode the backupKey in case it is url encoded
							backupKey = decodeURIComponent(backupKey.replace(/\+/g, '%20'));

							s3.putObject({
								Bucket: backupBucket,
								Key: backupKey,
								Body: base64data,
								ACL: 'public-read'
							},function (err, data) {
								console.log(arguments);
								console.log('Successfully uploaded file');

								if(deleteOriginal) {

									// Unencode the srcKey in case it is url encoded
									srcKey = decodeURIComponent(srcKey.replace(/\+/g, '%20'));

									s3.deleteObject({
										Bucket: srcBucket,
										Key: srcKey
									},function (err, data) {
										console.log(arguments);
										console.log('Successfully deleted file');
										callback();
										return;			
									});

								} else {
									callback();
									return;		
								}
							});
						});
					} else {
						callback();
						return;	
					}
				});	
			});
		});
	});
}

exports.checkUrlExists = function (Url, callback) {
	var options = {
		 method: 'HEAD',
		 host: url.parse(Url).host,
		 port: 80,
		 path: url.parse(Url).pathname
	};
	var req = http.request(options, function (r) {
		 callback( r.statusCode== 200);});
	req.end();
}	

const urlParser = require('url');

const supportedLibraries = {
    "http:": require('http'),
    "https:": require('https')
};

function downloadFile(url, callback) {
    var parsed = urlParser.parse(url);
    var lib = supportedLibraries[parsed.protocol || "http:"];
    if (lib) {
        lib.get(url, callback);
    } else {
			  callback({error: true, message: "invalid URL Protocol"});
		}
};

// Unit Tests //
var runUnitTests = false;

if(runUnitTests) {
	console.log("Running Unit Tests");

	DONT_USE_CACHE = true;
	
	exports.configure("alexa-ml", ".", true, ".\\ffmpeg.exe", true, true); // S3 Bucket, Local Working Directory, Use FFMPEG Flag (to convert format for Alexa), ffmpeg location, Windows mode, combine audio tags

	/*
	exports.estimateDurationForSSML(this, "This is some text to estimate. You guessed 'with or without you'. <audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/bbf3d8f0b710ba03d877bf624a05f4ba.mp3' /><audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/06b27abfcb5e5b24f3f15ccafe790e90.mp3' /> To make its interesting, this will be a pretty long sentence with a lot of details, like going to Mississippi or flying to the Moon or Italy and back.", 
			function(duration) {
				console.log("Duration estimate for SSML and audio tags is (in ms): " + duration);
			});
*/

	exports.reencodeMp3("test-upload-folder-convert-ffmpeg", "30610202-track+INTRO+Mario%2C+Let+Me+Love+You.mp3", "alexa-ml", "sounds/bti/tracks/30610202-track.mp3", undefined, undefined, false, function() {

		console.log("Encode Done");
	});

	/*
	{
		var string1 = "She then said to me, <voice name='Emma'>Hello, are you there?</voice> so I said <voice name='Ivy'>Of course I am!</voice>";
		var string2 = "<voice name='Nicole'>Voice line only</voice>";
		console.log("Input string 1: " + string1);
		console.log("Input string 2: " + string2);
		exports.convertStringsThroughPolly(string1, string2, function(convertedString1, convertedString2) {
			console.log("Converted string 1: " + convertedString1);
			console.log("Converted string 2: " + convertedString2);
		});
	}

	// Sample Output:
	// Converted string 1: She then said to me, <audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/504bdbd54074566dc05dcc611b4821d7.mp3' /> so I said <audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/fe585e0b3a806e0382e3a3017dee0df2.mp3' />
	// Converted string 2: <audio src='https://s3.amazonaws.com/alexa-ml/tempPolly/7cc7e17639a83e81a363e069b521e7e9.mp3' />

	{
		var string = "Something else <voice name='Nicole'>Voice line only from nicole but yet this is different than the others</voice><voice name='Ivy'>Another line from Ivy</voice><voice name='Emma'>ThirdLineFromEmma</voice> not inside of any of these tags <voice name='Ivy'>Another line from Ivy</voice> and another <voice name='Ivy'>Another line from Ivy</voice><voice name='Emma'>ThirdLineFromEmma</voice>";
		console.log("String: " + string);
		exports.convertStringsThroughPolly(string, undefined, function(convertedString1) {
			console.log("DONE Converted string: " + convertedString1);
		});		
	}


	let audioBuilder = new exports.AlexaAudioBuilder();

	audioBuilder.addMusicSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/larpente-sounds/zc/Day1EvenShorterConverted.mp3", volume: 0.15, fadeOutTime: 50, fadeOutDuration: 2});

	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Animals/Bear_Roar_1.mp3", delayMs: 2000, volume: 0.2});

	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Running_1.mp3", delayMs: 5000, volume: 0.1});

	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Gun_1.mp3", delayMs: 25000, volume: 0.1});
	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Gun_2.mp3", delayMs: 26000, volume: 0.5});
	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Gun_3.mp3", delayMs: 27000, volume: 1.0});
	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Gun_4.mp3", delayMs: 28000, volume: 1.0});
	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Actions/Gun_5.mp3", delayMs: 28000, volume: 1.0});

	audioBuilder.addSFXSequence({url: "https://s3.amazonaws.com/alexa-ml/sounds/sound-library/Fantasy_RPG/Death_Throes_2.mp3", delayMs: 28000, fadeInDuration: 1, fadeOutTime: 1, fadeOutDuration: 1});

	audioBuilder.addPollySequence({name: "Amy", text: "Be on the lookout... What was that? I hear something.  Let's get out of here... <break time='3s' />Brian, Brian I hear you.<break time='15s'/>Great, freaking Russell, you will be the death of us. Here they come.<break time='5s' />They won't be bothering us anymore.", delayMs: 1000, volume: 1.5});

	audioBuilder.addPollySequence({name: "Brian", text: "Help me. Help. Help me. Help. Help. Help me, this is Brian. Anyone out there..<break time='1s'/>Oh, Amy, I am so glad to see you. These zombies are coming. Should we fight them or should we flee?", delayMs: 2000, fadeInDuration: 6});

	audioBuilder.addPollySequence({name: "Russell", text: "Hi, I'm Russell. Can I join you two?", delayMs: 20000, volume: 0.5});


	// Test registering a voice and auto generating prosody and polly voice tag
	exports.registerVoiceName("MikeTest", {name: "Russell", pitch: "low", rate: "fast"});
	audioBuilder.addPollySequence({name: "MikeTest", text: "I'm Mike Test.", delayMs: 3000, volume: 0.5});	

	audioBuilder.buildAudioFile(function(outputUrl) {

		console.log("Output URL: " + outputUrl);

	});
	*/

}



