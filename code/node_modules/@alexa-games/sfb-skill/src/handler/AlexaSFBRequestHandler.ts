
import { HandlerInput, RequestHandler } from 'ask-sdk-core';
import { Response, Slot } from 'ask-sdk-model';
import { ACEDriver, UserInput, StoryMetadata, ABCImportPlugin, Choice, StoryStateHelper, Slot as ABCSlot, DriverExtension, ImporterExtension, InstructionExtension } from '@alexa-games/sfb-f';
import { CoreExtensionLoader } from './CoreExtensionLoader';
import { ConfigAccessor } from '../configAccessor';

import * as path from 'path';

type ExtensionType = DriverExtension | ImporterExtension | InstructionExtension;
export interface SFBHandlerConfig {
    locale: string;
    story: StoryMetadata;
    pollyVoiceConfig: any;
    defaultVoiceConfig: any;
    attributeTableName: any;
}


export class SFBRequestHandler implements RequestHandler {
	constructor(protected config: SFBHandlerConfig, protected customExtensions: ExtensionType[],
		protected configAccessor: ConfigAccessor, protected projectDir: string) {
    }

	canHandle(handlerInput : HandlerInput): boolean {
		return true;
    }

    getTableName(): string {
		return this.config.attributeTableName;
    }

	async handle(handlerInput : HandlerInput): Promise<Response> {
		// Load the story metadata
		const storyData: StoryMetadata = this.config.story;

		// Load persistent attributes (previous state)
		let gameState: any;

		try {
			gameState = await handlerInput.attributesManager.getPersistentAttributes();
		} catch (error) {
			return this.buildPersistentAttributeErrorResponse(error, handlerInput);
		}

		// Set up import plugins used (if any)
		let customImportPlugins: ABCImportPlugin[] = [];

		// Set up custom extensions		
		//TODO fix path
		let extensionLoader: CoreExtensionLoader = new CoreExtensionLoader(this.config.locale, this.configAccessor, {
			contentDir: path.resolve(this.projectDir, "res", this.config.locale),
			handlerInput: handlerInput
		});

		const customExtensions = this.customExtensions.concat(extensionLoader.getDriverExtensions());

		let userInput: UserInput = {
			handlerInput: handlerInput
		}
		//this.parseAsUserInput(handlerInput, extensionLoader.monetizationExtension, sessionAttributes);

		// Set up the ABC Story Driver
		let storyDriver: ACEDriver = new ACEDriver(storyData, customImportPlugins, customExtensions, this.config.pollyVoiceConfig, this.config.locale);

        // Configure default polly narrator
        const NARRATOR: any = this.config.defaultVoiceConfig;
		if (NARRATOR && this.config.defaultVoiceConfig.enabled) {
			storyDriver.configureDefaultPollyNarrator(NARRATOR.name, NARRATOR.pitch, NARRATOR.rate, NARRATOR.volume);
			storyDriver.turnOnDefaultPolly();
		} else {
			storyDriver.turnOffDefaultPolly();
		}

		/*
		* RUN Content
		*/
		// Identify Alexa Specific "Pause" intents
		let exitingIntents: boolean = this.isPausingRequest(handlerInput);

		// Run the story
		let stopChoice: Choice | null = StoryStateHelper.getChoiceByUserInput(gameState, userInput, this.config.locale);

		if (exitingIntents && (stopChoice == null || stopChoice.utterances.includes("*"))) {
			await storyDriver.pauseStory(userInput, gameState);
		} else {
			await storyDriver.resumeStory(userInput, gameState);
		}
	
		// Save the story state for the session
		handlerInput.attributesManager.setPersistentAttributes(storyDriver.getCurrentStoryState());
		await handlerInput.attributesManager.savePersistentAttributes();
		
		const response = handlerInput.responseBuilder.getResponse();

		/**
		 * Some fundamental Alexa Response rules.. .which should be handled by ASK.
		 */
		if (response.directives) {
			for (let directive of response.directives) {
				if (directive.type === "Connections.SendRequest") {
					// should end sesison has to be TRUE when sending Connections.SendRequest response.
					response.shouldEndSession = true;
					break;
				}
			}
		}

		if (response.shouldEndSession && response.reprompt) {
			// cannot have reprompt when shouldEndSession is true.
			delete response.reprompt;
		}
		return response;
	}

	protected isPausingRequest(handlerInput: HandlerInput): boolean {
		if (handlerInput.requestEnvelope.request.type === "SessionEndedRequest") {
			return true;
		}

		if (handlerInput.requestEnvelope.request.type === 'IntentRequest') {
			const intent = handlerInput.requestEnvelope.request.intent.name;

			return intent == "SessionEndedRequest" || intent == "AMAZON.StopIntent" || intent == "AMAZON.PauseIntent" || intent == "AMAZON.CancelIntent"
		}

		return false;
	}

	private buildPersistentAttributeErrorResponse(error: any, handlerInput: HandlerInput): Response {
		let err: string = error.toString();
		if (err.match(new RegExp("is not authorized to perform", "gi")) != null) {
			return handlerInput.responseBuilder
				.speak("Could not create or access your DynamoDB Table. Please verify that your IAM role has a Full Access permission to use DynamoDB.")
				.getResponse();
		} else if (err.match(new RegExp("Requested resource not found", "gi")) != null) {
			return handlerInput.responseBuilder
				.speak("A DynamoDB Table for this skill is being created. Please try again in 5 minutes.")
				.getResponse();
		} else {
			return handlerInput.responseBuilder
				.speak("Something went wrong while loading your progress. Try again later, and if the problem persists please contact the skill publisher.")
				.getResponse();
		}
	}
}

