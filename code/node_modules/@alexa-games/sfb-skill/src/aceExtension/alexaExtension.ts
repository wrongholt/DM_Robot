import { DriverExtension, DriverExtensionParameter, UserInput, Slot as ACESlot, StoryStateHelper } from '@alexa-games/sfb-f';
import { HandlerInput } from 'ask-sdk';

export class AlexaExtension implements DriverExtension {
    async post(param: DriverExtensionParameter) {
        const driver = param.driver;
        const handlerInput = param.userInputHelper.getHandlerInput();

        if (handlerInput) {
            const speechOutput: string = await driver.getSpeechSSMLText(); 

            // reprompt speech (speech for when player doesn't respond in 8 seconds)
            let repromptOutput: string = await driver.getRepromptSSMLText();

            if(!repromptOutput || repromptOutput.trim().length === 0) {
                // reprompt with speech if not defined by the content.
                repromptOutput = speechOutput;
            }

            if (StoryStateHelper.isStoryPaused(driver.getCurrentStoryState()) || StoryStateHelper.isEndingReached(driver.getCurrentStoryState())) {
                handlerInput.responseBuilder.withShouldEndSession(true);
            } else {
                handlerInput.responseBuilder.reprompt(repromptOutput);
            }
            
            handlerInput.responseBuilder
            .speak(speechOutput)
            .getResponse();
        }
    }

    async pre(param: DriverExtensionParameter) {
        const inputHelper = param.userInputHelper;
        const handlerInput = inputHelper.getHandlerInput();

        if (handlerInput) {
            const parsedInput = this.parseASKHandlerInput(handlerInput);
            if (parsedInput.intent) inputHelper.setInputIntent(parsedInput.intent);
            if (parsedInput.value) inputHelper.setInputValue(parsedInput.value);
            if (parsedInput.slots) inputHelper.setInputSlots(parsedInput.slots);
        }
    }

    private parseASKHandlerInput(handlerInput: HandlerInput): UserInput {
        // Parse the incoming request
        let userInput: UserInput = {
        }

        if (handlerInput.requestEnvelope.request.type === 'LaunchRequest' || handlerInput.requestEnvelope.request.type === 'SessionEndedRequest') {
            userInput.intent = handlerInput.requestEnvelope.request.type;
        } else if (handlerInput.requestEnvelope.request.type === 'IntentRequest') {
            userInput.intent = handlerInput.requestEnvelope.request.intent.name;

            let slots: {[key: string]: any} | undefined = handlerInput.requestEnvelope.request.intent.slots;
            let foundSlots: ACESlot[] = [];
            let valueStringCollections: string = "";

            if (slots) {
                for (let slotName of Object.keys(slots)) {
                    if (slots[slotName] && slots[slotName].value) {
                        let resolutionEntities: any = slots[slotName].resolutions;

                        // TODO: Make this work
                        let slotIndexToUse = 0;
                        if (resolutionEntities && resolutionEntities.resolutionsPerAuthority) {
                            for(let i = 0; i < resolutionEntities.resolutionsPerAuthority.length; i++) {
                                
                                console.log("CHECKING " + i + " " + JSON.stringify(resolutionEntities.resolutionsPerAuthority[i]));

                                if(resolutionEntities.resolutionsPerAuthority[i].status.code === 'ER_SUCCESS_MATCH') {
                                    slotIndexToUse = i;
                                    console.log("BREAKING at : " + slotIndexToUse);
                                    break;
                                }
                            }
                        }

                        if (resolutionEntities && resolutionEntities.resolutionsPerAuthority && resolutionEntities.resolutionsPerAuthority[slotIndexToUse].status.code != 'ER_SUCCESS_NO_MATCH') {
                                let resolution: string = resolutionEntities.resolutionsPerAuthority[slotIndexToUse].values[0].value.name;
                                foundSlots.push({
                                    name: slots[slotName].name,
                                    value: resolution
                                });
                                
                                valueStringCollections += " " + resolution;
                        } 
                        else if (!resolutionEntities || !resolutionEntities.resolutionsPerAuthority){
                            foundSlots.push({
                                name: slots[slotName].name,
                                value: slots[slotName].value || ""
                            });	
                            valueStringCollections += " " + slots[slotName].value;
                        }
                    }
                }
            }

            if (valueStringCollections.trim().length > 0) {
                userInput.value = valueStringCollections.trim();
            }

            userInput.slots = foundSlots;
        }

        return userInput;
    }
}