import { SceneAudioItem, VisualOptions, AudioItem, AlexaAudioType } from '../aceEntities/interfaces';

export class PlayStage {
    private visitedSceneIDsOnRun: string[] = [];

    private speechAudioSequence: SceneAudioItem[] = [];

    private repromptAudioSequence: SceneAudioItem[] = [];

    private recapAudioSequence: SceneAudioItem[] = [];

    private visualOptions: VisualOptions[] | undefined = undefined;

    private currentSceneAudioQueue: SceneAudioItem = {
        foreground: [],
        background: []
    };

    private currentSceneRepromptAudioQueue: SceneAudioItem = {
        foreground: [],
        background: []
    };

    private currentSceneRecapAudioQueue: SceneAudioItem = {
        foreground: [],
        background: []
    };

    constructor() {
        this.resetStage();
    }

    public resetStage(): void {
        this.visitedSceneIDsOnRun = [];

        this.speechAudioSequence = [];
    
        this.repromptAudioSequence = [];
    
        this.recapAudioSequence = [];
    
        this.visualOptions = undefined;
    
        this.currentSceneAudioQueue = {
            foreground: [],
            background: []
        };
    
        this.currentSceneRepromptAudioQueue = {
            foreground: [],
            background: []
        };
    
        this.currentSceneRecapAudioQueue = {
            foreground: [],
            background: []
        };
    }

    public logVisitedScene(sceneID: string): void {
        this.visitedSceneIDsOnRun.push(sceneID);
    }

    public getStageSpeechAudioSequence(): SceneAudioItem[] {
        return this.condensePollyItem(this.speechAudioSequence);
    }

    public getStageRepromptAudioSequence(): SceneAudioItem[] {
        return this.condensePollyItem(this.repromptAudioSequence);
    }

    public getStageRecapAudioSequence(): SceneAudioItem[] {
        return this.condensePollyItem(this.recapAudioSequence);
    }
    

    public getStageVisualOptions(): VisualOptions[] | undefined {
        return this.visualOptions;
    }

    public setStageSpeechAudioSequence(audio: SceneAudioItem[]): void {
        this.speechAudioSequence = audio;
    }

    public setStageRepromptAudioSequence(audio: SceneAudioItem[]): void {
        this.repromptAudioSequence = audio;
    }

    public setStageRecapAudioSequence(audio: SceneAudioItem[]): void {
        this.recapAudioSequence = audio;
    }
    
    public setStageVisualOptions(visuals: VisualOptions[]): void {
        this.visualOptions = visuals;
    }

    public appendStageSpeechAudioSequence(audio: SceneAudioItem[]): void {
        this.speechAudioSequence = this.speechAudioSequence.concat(audio);
    }

    public appendStageRepromptAudioSequence(audio: SceneAudioItem[]): void {
        this.repromptAudioSequence = this.repromptAudioSequence.concat(audio);
    }

    public appendStageRecapAudioSequence(audio: SceneAudioItem[]): void {
        this.recapAudioSequence = this.recapAudioSequence.concat(audio);
    }

    public appendStageVisuals(visuals: VisualOptions): void {
        if (!this.visualOptions) {
            this.visualOptions = [];
        }
        
        this.visualOptions.push(visuals);
    }

    public startNewScene(): void {
        this.currentSceneAudioQueue = {
            foreground: [],
            background: []
        };
    
        this.currentSceneRepromptAudioQueue = {
            foreground: [],
            background: []
        };
    
        this.currentSceneRecapAudioQueue = {
            foreground: [],
            background: []
        };
    }

    public appendSceneSpeechForeground(audioItem: AudioItem[]): void {
        this.currentSceneAudioQueue.foreground = this.currentSceneAudioQueue.foreground.concat(audioItem);
    }

    public appendSceneSpeechBackground(audioItem: AudioItem[]): void {
        this.currentSceneAudioQueue.background = this.currentSceneAudioQueue.foreground.concat(audioItem);
    }

    public appendSceneRepromptForeground(audioItem: AudioItem[]): void {
        this.currentSceneRepromptAudioQueue.foreground = this.currentSceneRepromptAudioQueue.foreground.concat(audioItem);
    }

    public appendSceneRepromptBackground(audioItem: AudioItem[]): void {
        this.currentSceneRepromptAudioQueue.background = this.currentSceneRepromptAudioQueue.background.concat(audioItem);
    }

    public appendSceneRecapForeground(audioItem: AudioItem[]): void {
        this.currentSceneRecapAudioQueue.foreground = this.currentSceneRecapAudioQueue.foreground.concat(audioItem);
    }

    public appendSceneRecapBackground(audioItem: AudioItem[]): void {
        this.currentSceneRecapAudioQueue.background = this.currentSceneRecapAudioQueue.background.concat(audioItem);
    }

    public getSpeechSceneAudio(): SceneAudioItem {
        return this.currentSceneAudioQueue;
    }

    public getRepromptSceneAudio(): SceneAudioItem {
        return this.currentSceneRepromptAudioQueue;
    }

    public getRecapSceneAudio(): SceneAudioItem {
        return this.currentSceneRecapAudioQueue;
    }

    public closeScene(): void {
        if (this.currentSceneAudioQueue.foreground.length > 0 || this.currentSceneAudioQueue.background.length > 0) {
            this.speechAudioSequence = this.speechAudioSequence.concat(this.currentSceneAudioQueue);
        }

        if (this.currentSceneRepromptAudioQueue.foreground.length > 0 || this.currentSceneRepromptAudioQueue.background.length > 0) {
            this.repromptAudioSequence = this.repromptAudioSequence.concat(this.currentSceneRepromptAudioQueue);
        }

        if (this.currentSceneRecapAudioQueue.foreground.length > 0 || this.currentSceneRecapAudioQueue.background.length > 0) {
            this.recapAudioSequence = this.recapAudioSequence.concat(this.currentSceneRecapAudioQueue);
        }
    }

    private condensePollyItem(_sceneAudio: SceneAudioItem[]): SceneAudioItem[] {
        let sceneAudio: SceneAudioItem[] = JSON.parse(JSON.stringify(_sceneAudio));
        let optimizedStageSpeechSequence: SceneAudioItem[] = [];
        // combine back-to-back polly items sharing same voice property into one.
        let tempItem: SceneAudioItem | undefined = undefined;
        let buildingItem: AudioItem | undefined = undefined;
        let tempPushed: boolean = false;
        for (let sceneItem of sceneAudio) {
            if (sceneItem.background.length > 0) {
                if (tempItem) {
                    if (buildingItem) {
                        tempItem.foreground.push(buildingItem);
                        buildingItem = undefined;
                    }

                    tempPushed = true;
                    optimizedStageSpeechSequence.push(tempItem);
                    tempItem = undefined;
                }

                optimizedStageSpeechSequence.push(sceneItem);
                continue;
            }

            for (let foregroundItem of sceneItem.foreground) {
                if (!tempItem) {
                    tempPushed = false;
                    tempItem = {
                        foreground: [],
                        background: []
                    };
                }

                if (foregroundItem.type === AlexaAudioType.POLLY) {
                    if (buildingItem) {
                        if (foregroundItem.volume == buildingItem.volume && foregroundItem.options && buildingItem.options
                        && foregroundItem.options.pitch == buildingItem.options.pitch && foregroundItem.options.rate == buildingItem.options.rate
                        && foregroundItem.options.voice == buildingItem.options.voice) {
                            buildingItem.content += ` ${foregroundItem.content}`;
                        } else {
                            tempItem.foreground.push(buildingItem);

                            buildingItem = foregroundItem;
                        }
                    } else {
                        buildingItem = foregroundItem;
                    }
                } else {
                    if (buildingItem) {
                        tempItem.foreground.push(buildingItem);
                    }
                    tempItem.foreground.push(foregroundItem);
                    buildingItem = undefined;
                }
            }
        }

        if (buildingItem && tempItem) {
            tempItem.foreground.push(buildingItem);
        }


        if (!tempPushed && tempItem) {
            optimizedStageSpeechSequence.push(tempItem);
        }
        return optimizedStageSpeechSequence;
    }
}