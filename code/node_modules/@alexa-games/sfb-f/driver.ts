declare var require: any

// Are we running on windows or linux/mac?
// Make this work on a mac and auto detect which platform I am on
declare var process : {
	env: {
      platform: string,
      ABC_DEBUG_PAD_SIZE: string
	},
	platform: string
}

import { BuiltInScenes, UserInput, StoryMetadata,
    ABCImportPlugin, SceneDirection, SceneDirectionType,
    Choice, Scene, AudioItem, SceneAudioItem, AlexaAudioType,
    AudioBlendOption, ChoiceHistoryItem, StateDiffItem, VisualOptions,
    ResultOption } from './aceEntities/interfaces';

import { StoryAccessor } from './storyEntities/StoryAccessor';

import { DefaultFormatImportPlugin } from './importPlugins/DefaultFormatImportPlugin';

import { isDriverExtension, isInstructionExtension,
    InstructionExtension, ImporterExtension, DriverExtension } from './extensions/ACEExtension';

import { StoryStateHelper } from './StoryStateHelper';

import { createHash } from 'crypto';
import { PlayStage } from './storyEntities/PlayStage';
import { UserInputHelper } from './importPlugins/userInputHelper';

const TOTAL_SCENES_PROCESS_SAFEGUARD = 1000;
const isWin = (process.platform === "win32");
const AlexaPolly = require('@alexa-games/sfb-polly');

let POLLY_ENABLED = true;
let pollyConfig : any = undefined;

type ACEExtensionType = ImporterExtension | DriverExtension | InstructionExtension;
export class ACEDriver {
    private static STORY_METADATA_CACHE: {[key: string]: {[key: string]: Scene}} = {};
    public static debug: boolean = false;
    public static testing: boolean = false;

    /**
     * flag this variable to alway run the average value for dice rolls.
     */
    public static probabilityOff: boolean = false;

    private isPollyAsDefault: boolean = false;

    private importHandlersByType : {[key: string] : ABCImportPlugin} = {};

    private customExtensions: ACEExtensionType[] = [];

    private resultOptions: ResultOption[] = [];

    private storyState: {[key: string]: any};

    private storyAccessor: StoryAccessor;
    
    private stage: PlayStage;

    private playQueue: {
        sceneID: string,
        property: string
    }[] = [];

    private unhandledChoiceFlag = false;
    private isPausing: boolean = false;
    private isRepeating: boolean = false;
    private locale: string;

    voiceName: string = "Brian";
    pitch: string = "";
    rate: string = "";
    volume: number = 1;
    historySize: number = 10;

    constructor(storyMetadata: StoryMetadata, customImportPlugins?: ABCImportPlugin[], extensions?: ACEExtensionType[], pollyConfiguration?: any, locale: string = 'en-US') {
        this.locale = locale;
        POLLY_ENABLED = pollyConfiguration ? pollyConfiguration.enabled : false; // Default to polly config off
        pollyConfig = pollyConfiguration || {};

        if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
            if (pollyConfiguration) {
                AlexaPolly.configureOptions(pollyConfiguration);
            } else {
                if(isWin) {
                    AlexaPolly.configureOptions({bucketName: "cyoa-public", combineAudioTags: true, dontUseCache: false, FFMPEGLocation: "..\\ffmpeg.exe", windowsOS: true, workingDir: "c:\\Tmp", ffmpegBinName: "ffmpeg.exe"});
                } else {
                    AlexaPolly.configureOptions({bucketName: "cyoa-public", combineAudioTags: true, dontUseCache: false});
                }
            }
        }
        
        this.storyAccessor = new StoryAccessor(storyMetadata);
        this.storyState = {};

        this.stage = new PlayStage();
        
        let importPlugins: ABCImportPlugin[] = [
			new DefaultFormatImportPlugin()            
		];

		if (customImportPlugins) {
			importPlugins = importPlugins.concat(customImportPlugins);
        }

		for (let importPlug of importPlugins) {
			this.importHandlersByType[importPlug.pluginName] = importPlug;
        }
        
        if (extensions) {
            this.customExtensions = this.customExtensions.concat(extensions);
        }
    }

    /**
     * invoke before calling resumeStory if the story history and progress needs to be reset by running the start sequence.
     * onStart implementation of all registered extensions are run.
     * 
     * @param startingStoryState 
     */
    public async resetStory(startingStoryState?: {[key: string]: any}) {
        this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));

        StoryStateHelper.setCurrentSceneID(this.storyState, BuiltInScenes.StartScene);
        StoryStateHelper.resetAvailableChoices(this.storyState);
        StoryStateHelper.resetChoiceHistory(this.storyState);
        
        return;
    }

    /**
     * Resume the story.
     * If story has been paused, run the resume cycle by playing the 'Resume' scene first.
     * Otherwise, Run normally from the bookmarked scene ID.
     * 
     * @param userInput 
     * @param startingStoryState 
     */
    public async resumeStory(_userInput: UserInput, startingStoryState?: {[key: string]: any}) {
        try {
            this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));

            // create instructions memory
            if (!this.storyState.system_instruction_mem) {
                this.storyState.system_instruction_mem = {};
            }

            if (StoryStateHelper.isEndingReached(this.storyState)) {
                delete this.storyState.system_prevRecap;
                delete this.storyState.system_prevSpeech;
        
                StoryStateHelper.setEndingReached(this.storyState, false);
            }
            
            this.playQueue = [];
            this.unhandledChoiceFlag = false; // Reset to false
            this.isRepeating = false;

            // apply user input extension by DriverExtensions
            const inputHelper = new UserInputHelper(_userInput);
            for (let extension of this.customExtensions) {
                if (!isDriverExtension(extension)) {
                    continue;
                }

                await extension.pre({
                    driver: this,
                    storyState: this.storyState,
                    userInputHelper: inputHelper
                });
            }

            const userInput = inputHelper.getUserInput();

            if (!StoryStateHelper.isStoryPaused(this.storyState)) {
                await this.processChoice.call(this, userInput);
            }

            if (!this.isRepeating) {
                if(ACEDriver.debug) console.log("[DEBUG] Play queue length: " + this.playQueue.length);
                if (this.playQueue.length === 0) {
                    let bookmarkedSceneID: string | null = StoryStateHelper.getCurrentSceneID(this.storyState);
                    if(ACEDriver.debug) console.log("[DEBUG] Current bookmark: " + bookmarkedSceneID);
        
                    if (bookmarkedSceneID == null) {
                        if(ACEDriver.debug) console.log("[DEBUG] Enqueue start scene");
        
                        this.playQueue.push({
                            sceneID: BuiltInScenes.StartScene,
                            property: "narration"
                        });
                    } else {
                        let resumeExists: boolean = false;

                        try {
                            let scene: Scene = await this.getSceneByID(BuiltInScenes.ResumeScene);

                            if (scene) {
                                resumeExists = true;
                            }                        
                        } catch(err) {
                            resumeExists = false;   
                        }

                        if (StoryStateHelper.isStoryPaused(this.storyState) && resumeExists) {
                            if(ACEDriver.debug) console.log("[DEBUG] Enqueue resume scene, and clear choices.");
                            StoryStateHelper.resetAvailableChoices(this.storyState);
                            if (StoryStateHelper.getCurrentSceneID(this.storyState) !== BuiltInScenes.PauseScene) {
                                this.storyState.resume = StoryStateHelper.getCurrentSceneID(this.storyState);
                            }
                            this.playQueue.push({
                                sceneID: BuiltInScenes.ResumeScene,
                                property: "narration"
                            });
                        } else {
                            if(ACEDriver.debug) console.log("[DEBUG] Enqueue saved scene: " + bookmarkedSceneID);
        
                            this.playQueue.push({
                                sceneID: bookmarkedSceneID,
                                property: "narration"
                            });    
                        }

                        // Also set a flag to indicate that we hit an unhandled choice so the caller can do something different if they want to
                        this.unhandledChoiceFlag = true;
                    }
                }
        
                StoryStateHelper.setStoryPaused(this.storyState, false);
                
                if (!this.storyState.system_originStack) {
                    this.storyState.system_originStack = [];
                }

                this.storyState.system_originStack.push(this.playQueue[0]);

                if (this.storyState.system_originStack.length > this.historySize) {
                    // too large, remove first item
                    this.storyState.system_originStack.splice(0, 1);
                }

                let totalScenesProcessedCount = 0;

                while (this.playQueue.length > 0 && !this.isPausing) {

                    let dequeuedSceneID: {
                        sceneID: string,
                        property: string
                    } = this.playQueue.splice(0, 1)[0];

                    if(ACEDriver.debug) console.log("[DEBUG] Setting the current scene to: " + dequeuedSceneID);
                    this.stage.logVisitedScene(dequeuedSceneID.sceneID);
        
                    StoryStateHelper.setCurrentSceneID(this.storyState, dequeuedSceneID.sceneID);
                    
                    let preProcessState: string = JSON.stringify(this.storyState);            
        
                    await this.processScene.call(this, undefined, dequeuedSceneID.property);

                    if (ACEDriver.testing) {
                        let beforeStructure: any = JSON.parse(preProcessState);
                        console.log("\n");
                        check("", beforeStructure, this.storyState);
                    }

                    totalScenesProcessedCount++;
                    if(totalScenesProcessedCount >= TOTAL_SCENES_PROCESS_SAFEGUARD) {
                        throw "[ACE Driver - Infinite Loop] Looped " + TOTAL_SCENES_PROCESS_SAFEGUARD + " times, last scene ID was: " + dequeuedSceneID.sceneID + ". Please fix your inifite loop.";
                    }
                }

                if (this.isPausing) {
                    this.isPausing = false;
                    await this.pauseStory(_userInput);
                }
            }

            this.storyState.system_prevSpeech = this.stage.getStageSpeechAudioSequence();
            this.storyState.system_prevReprompt = this.stage.getStageRepromptAudioSequence();
            this.storyState.system_prevRecap = this.stage.getStageRecapAudioSequence();

            // apply user input extension by DriverExtensions
            for (let extension of this.customExtensions) {
                if (!isDriverExtension(extension)) {
                    continue;
                }

                await extension.post({
                    driver: this,
                    storyState: this.storyState,
                    userInputHelper: inputHelper                    
                });
            }

            return;
        } catch(err) {
            throw err;
        }
        
    }

    /**
     * Run the pause sequence by playing the 'Pause' scene.
     * 
     * @param startingStoryState 
     */
    public async pauseStory(_userInput: UserInput, startingStoryState?: {[key: string]: any}) {
        this.storyState = Object.assign({}, startingStoryState || this.storyState);

        // create instructions memory
        if (!this.storyState.system_instruction_mem) {
            this.storyState.system_instruction_mem = {};
        }

        let savingSceneID: string | null = StoryStateHelper.getCurrentSceneID(this.storyState);

        if (savingSceneID == BuiltInScenes.ResumeScene) {
            savingSceneID = this.storyState.resume
        }

        StoryStateHelper.setCurrentSceneID(this.storyState, BuiltInScenes.PauseScene);
            
        let preProcessState: string = JSON.stringify(this.storyState);            

        await this.processScene.call(this);

        if (ACEDriver.testing) {
            let beforeStructure: any = JSON.parse(preProcessState);
            console.log("\n");
            check("", beforeStructure, this.storyState);
        }

        // saving the previous scene for next resume.
        StoryStateHelper.setCurrentSceneID(this.storyState, savingSceneID === null ? BuiltInScenes.StartScene: savingSceneID);

        StoryStateHelper.setStoryPaused(this.storyState, true);

        // apply user input extension by DriverExtensions
        const inputHelper = new UserInputHelper(_userInput);
        for (let extension of this.customExtensions) {
            if (!isDriverExtension(extension)) {
                continue;
            }

            await extension.post({
                driver: this,
                storyState: this.storyState,
                userInputHelper: inputHelper                    
            });
        }

        return;
    }

    /**
     * Undo a choice.
     */
    public async undoLastChoice(storyState: {[key: string]: any}) {
        let choiceHistory: ChoiceHistoryItem[] = StoryStateHelper.getChoiceHistory(storyState);

        if (choiceHistory && choiceHistory.length > 0){ 
            let lastChoice: ChoiceHistoryItem = choiceHistory[choiceHistory.length - 1];

            for (let stateDiff of lastChoice.stateDiff) {
                if (stateDiff.beforeValue === undefined) {
                    delete storyState[stateDiff.itemName];
                } else {
                    storyState[stateDiff.itemName] = stateDiff.beforeValue;
                }
            }            

            choiceHistory.splice(-1, 1);// pop 
        }
        
        StoryStateHelper.setChoiceHistory(storyState, choiceHistory);
        return;
    }

    public async enqueueNextSceneID(nextSceneID: string) {
        this.playQueue.push({
            sceneID: nextSceneID,
            property: "narration"
        });
    }

    /**
     * Configure the default polly narrator settings.
     * @param voiceName 
     * @param pitch 
     * @param rate 
     * @param volume 
     */
    public configureDefaultPollyNarrator(voiceName: string, pitch: string, rate: string, volume: number) {
        this.voiceName = voiceName;
        this.pitch = pitch;
        this.rate = rate;
        this.volume = volume;
        AlexaPolly.registerVoiceName(voiceName, {name: voiceName, rate: rate, pitch: pitch});
    }    

    /**
     * Turning on the 'default polly' causes all narration texts (including the ones not surrounded by the 'voice' tag) to be read in polly voice.
     * The polly voice setting for this can be configured by calling configureDefaultPollyNarrator().
     */
    public turnOnDefaultPolly() {
        this.isPollyAsDefault = true;
    }

    /**
     * Turning off the 'default polly' causes all narration texts (texts NOT surrounded by the 'voice' tag) to be processed as non-polly voice.
     */
    public turnOffDefaultPolly() {
        this.isPollyAsDefault = false;
    }

    public buildAudioBuilder(audioBuilder : any) {
        return new Promise<string> (async (resolve, reject) => {
                audioBuilder.buildAudioFile(function(outputUrl : string, err : any) {

                    if(err) {
                        reject(err);
                        return;
                    }

                    resolve(outputUrl);
                }, this);    
        });
    }

    public combineSSMLAudioTags(ssmlIn : string) {
        return new Promise<string> (async (resolve, reject) => {
            console.log("combining: " + ssmlIn);
            AlexaPolly.combineAudioTags(ssmlIn, function(ssmlOut : string) {
                console.log("combined to : " + ssmlOut);
                resolve(ssmlOut);
            });
        });
    }

    public async getSpeechSSMLText() {
        try {
            let {ssml} = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());

            return ssml;
        } catch (err) {
            throw err;
        }
    }  

    public async getSpeechSSMLAndPrettyText() {
        try {
            let {ssml, pretty} = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());

            return {ssml, pretty};
        } catch (err) {
            throw err;
        }
    }  

    public async getRepromptSSMLText() {
        try {
            let {ssml} = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());

            return ssml;
        } catch (err) {
            throw err;
        }
    }

    public async getRepromptSSMLAndPrettyText() {
        try {
            let {ssml, pretty} = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());

            return {ssml, pretty};
        } catch (err) {
            throw err;
        }
    }  

    public async getVisuals() : Promise<VisualOptions[] | undefined> {
        return this.stage.getStageVisualOptions();
    }

    public async buildAudioScenes(sceneAudioItemList: SceneAudioItem[]) {
        try {
            let overallSSML : string = "";
            let prettySSML : string = "";

            for (let audioItem of sceneAudioItemList) {
                let foregroundSSML: string = "";
        
                for (let foregroundAudio of audioItem.foreground) {
                    // Build the foreground audio up into a single ssml tag
                    if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
                        if (foregroundAudio.type === AlexaAudioType.AUDIO) {
                            // If values are defaults, then don't change the audio file at all and keep it at it's original quality
                            if(!POLLY_ENABLED || (foregroundAudio.delay == 0 && foregroundAudio.volume == 1.0) ) {
                                foregroundSSML += `<audio src='${foregroundAudio.content}' />`;    
                                prettySSML += `<audio src='${foregroundAudio.content}' />`;
                            } else {
                                let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                                audioBuilder.addSFXSequence({url: foregroundAudio.content, delayMs: foregroundAudio.delay, volume: foregroundAudio.volume});
                                let audioUrl = await this.buildAudioBuilder(audioBuilder);
        
                                foregroundSSML += `<audio src='${audioUrl}' />`;    
                                prettySSML += `<audio src='${audioUrl}' />`;
                            }
                        } else if (foregroundAudio.type === AlexaAudioType.POLLY) {
                            if(foregroundAudio.options) {
                                if(!POLLY_ENABLED) {
                                    const hasProsodyMod = !!((foregroundAudio.options.pitch && foregroundAudio.options.pitch.length > 0)  || (foregroundAudio.options.rate && foregroundAudio.options.rate.length > 0) || (foregroundAudio.options.volume && foregroundAudio.options.volume.length > 0));
                                    let voiceOpenTag: string = `<voice name='${foregroundAudio.options.voice}'>`;
                                    let voiceCloseTag: string = "</voice>";
                                    if (hasProsodyMod) {
                                        let prosodyOptions = "";
                                        if (foregroundAudio.options.pitch && foregroundAudio.options.pitch.length > 0) {
                                            prosodyOptions += `pitch='${foregroundAudio.options.pitch}'`;
                                        }

                                        if (foregroundAudio.options.rate && foregroundAudio.options.rate.length > 0) {
                                            prosodyOptions += ` rate='${foregroundAudio.options.rate}'`;
                                        }

                                        if (foregroundAudio.options.volume && foregroundAudio.options.volume.length > 0) {
                                            prosodyOptions += ` volume='${foregroundAudio.options.volume}'`;
                                        }
                                        
                                        voiceOpenTag += `<prosody ${prosodyOptions}>`;
                                        voiceCloseTag = `</prosody>${voiceCloseTag}`
                                    }
                                    
                                    foregroundSSML += `${voiceOpenTag}${foregroundAudio.content}${voiceCloseTag}`;
                                    prettySSML += `${voiceOpenTag}${foregroundAudio.content}${voiceCloseTag}`;
                                } else {
                                    let audioBuilder = new AlexaPolly.AlexaAudioBuilder();

                                    audioBuilder.addPollySequence({name: foregroundAudio.options.voice, text: foregroundAudio.content, delayMs: foregroundAudio.delay, volume: foregroundAudio.volume, rate: foregroundAudio.options.rate, pitch: foregroundAudio.options.pitch});
                                    let audioUrl = await this.buildAudioBuilder(audioBuilder);

                                    foregroundSSML += `<audio src='${audioUrl}' />`;
                                    prettySSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                }
                            }
                        } else {
                            if(ACEDriver.testing && pollyConfig.enabledInPreview) {
                                let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                                audioBuilder.addPollySequence({ name: 'Amy', text: foregroundAudio.content, volume: foregroundAudio.volume});
                                let audioUrl = await this.buildAudioBuilder(audioBuilder);
                                foregroundSSML += `<audio src='${audioUrl}' />`;
                                prettySSML += ` ${foregroundAudio.content}`;
                            } else {
                                foregroundSSML += ` ${foregroundAudio.content}`;
                                prettySSML += ` ${foregroundAudio.content}`;
                            }
                        }

                    } else {
                        // We are testing, so just return something that will not be valid ssml
                        if (foregroundAudio.type === AlexaAudioType.AUDIO) {
                            foregroundSSML += `<audio src='${foregroundAudio.content}'/>`;
                            prettySSML += `<audio src='${foregroundAudio.content}'/>`;
                        } else if (foregroundAudio.type === AlexaAudioType.POLLY) {
                            if(foregroundAudio.options) {
                                foregroundSSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                prettySSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                //                            foregroundSSML += `(POLLY:name=${foregroundAudio.options.voice} text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume} rate=${foregroundAudio.options.rate} pitch=${foregroundAudio.options.pitch})`;
                            } else {
                                foregroundSSML += `(POLLY:name=ERROR_NO_POLLY_NAME_SET text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume})`;
                                prettySSML += `(POLLY:name=ERROR_NO_POLLY_NAME_SET text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume})`;
                            }
                        } else {
                            foregroundSSML += ` ${foregroundAudio.content}`;
                            prettySSML += ` ${foregroundAudio.content}`;
                        }
                    }
                }

                let primaryBackgroundAudioItem : AudioItem | undefined = undefined;
                for (let backgroundAudio of audioItem.background) {

                    if (backgroundAudio.type === AlexaAudioType.AUDIO) {
                        // TODO: Loop through and make a whole audio builder out of all the background items
                        // TODO: Right now it only supports one background audio item
                        primaryBackgroundAudioItem = backgroundAudio;
                    }
                }

                // Now combine all of the audio tags if there is background music, otherwise leave them alone. Only works if polly is enabled.
                if(!POLLY_ENABLED || !primaryBackgroundAudioItem) {
                    overallSSML += foregroundSSML;
                } else if(primaryBackgroundAudioItem) {                
                    if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
                        let foregroundCombinedSSML = await this.combineSSMLAudioTags(foregroundSSML);
                
                        // Now grab and replace the first URL found in the above and mix it with the background music
                        let srcUrlRegex = /<audio src='([^']*?)'/g;					
                        let srcUrlMatch = srcUrlRegex.exec(foregroundCombinedSSML);
                    
                        if(srcUrlMatch && srcUrlMatch[1]) {
                            let foregroundAudioUrl = srcUrlMatch[1];

                            let foregroundDelay = 0;
                            let backgroundDelay = primaryBackgroundAudioItem.delay;

                            if(backgroundDelay < 0) {
                                foregroundDelay += Math.abs(backgroundDelay);
                                backgroundDelay = 0;
                            }

                            let audioBuilder = new AlexaPolly.AlexaAudioBuilder();

                            if (primaryBackgroundAudioItem.options && primaryBackgroundAudioItem.options.blend === AudioBlendOption.LONGEST) {
                                audioBuilder.trimSetting = "longest";
                            } else {
                                audioBuilder.trimSetting = "first";
                            }

                            audioBuilder.addSFXSequence({url: foregroundAudioUrl, delayMs: foregroundDelay, volume: 1.0});
                            audioBuilder.addSFXSequence({url: primaryBackgroundAudioItem.content, delayMs: backgroundDelay, volume: primaryBackgroundAudioItem.volume});
                            
                            let combinedForegroundBackgroundUrl = await this.buildAudioBuilder(audioBuilder);

                            foregroundCombinedSSML = foregroundCombinedSSML.replace(foregroundAudioUrl, combinedForegroundBackgroundUrl);
                        }

                        overallSSML += foregroundCombinedSSML;
                    } else {
                        overallSSML += foregroundSSML + `(BGM:<audio src='${primaryBackgroundAudioItem.content}' delay='${primaryBackgroundAudioItem.delay}' volume='${primaryBackgroundAudioItem.volume}'/>)`;
                    } 
                }
            }

            // Now, run combine audio tags again on the whole entire thing in case there are still more than 5 audio tags across all scenes.
            let overallCombinedSSML : string;
            
            if ((!ACEDriver.testing && (AlexaPolly.hasMoreThanFiveAudioTags(overallSSML) || pollyConfig.combineToSingleAudioFile) ) 
                || (ACEDriver.testing && pollyConfig.enabledInPreview)) {
                overallCombinedSSML = await this.combineSSMLAudioTags(overallSSML);
            } else {
                overallCombinedSSML = overallSSML;
            }

            return {ssml: overallCombinedSSML, pretty: prettySSML};
        } catch(err) {
            throw err; 
        }
    }

    /**
     * Get the current story state.
     */
    public getCurrentStoryState(): {[key: string]: any} {
        return JSON.parse(JSON.stringify(this.storyState)); //deep copy
    }

    public getResultOptions(): ResultOption[] {
        return this.resultOptions;
    }

    /**
     * See if the scene marked as ending, or scene leading to no new choice has been reached as a result of the current resume/run.
     */
    public isEndingReached(): boolean {
        return StoryStateHelper.isEndingReached(this.storyState);
    }

    /**
     * See if a choice was unhandled and allow the caller to do something else if they need to.
     */
    public isUnhandledChoice(): boolean {
        return this.unhandledChoiceFlag;        
    }

    /**
     * Execute the selected choice indicated by the user input.  
     */
    public async processChoice(userInput: UserInput): Promise<any> {
        return new Promise<any> (async (resolve, reject) => {
            if (ACEDriver.debug) console.log("[DEBUG] Calling processChoice");

            let availableChoices: Choice[] = StoryStateHelper.getAvailableChoices(this.storyState)

            if (ACEDriver.debug) console.log("[DEBUG] Loading Available Choices: " + JSON.stringify(availableChoices, null, 4));

            let selectedChoice: Choice | null = StoryStateHelper.getChoiceByUserInput(this.storyState, userInput, this.locale);

            if (ACEDriver.debug) console.log(`[DEBUG] With UserInput=${JSON.stringify(userInput)}, Selected Choice=${JSON.stringify(selectedChoice, null, 4)}`);

            if (selectedChoice == null) {
                if ((!this.storyState.system_prevRecap || this.storyState.system_prevRecap.length == 0)
                    && (!this.storyState.system_prevSpeech || this.storyState.system_prevSpeech.length == 0)) {
                    this.isRepeating = false;
                } else {
                    if (this.storyState.system_prevRecap && this.storyState.system_prevRecap.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevRecap);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevRecap);
                    } else if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevSpeech);
                    }
    
                    if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevRecap);
                    }                
    
                    this.isRepeating = true;
                }
            } else {
                StoryStateHelper.setSelectedChoiceID(this.storyState, selectedChoice.id);

                let beforeState: any = JSON.parse(JSON.stringify(this.storyState));
                try {
                    let tempChoiceInstructionAddress: string = StoryStateHelper.getCurrentSceneID(this.storyState) + ":" + selectedChoice.id + ":" + -1;

                    this.storyState.system_instruction_mem[tempChoiceInstructionAddress] = selectedChoice.sceneDirections;

                    await this.performInstructions.call(this, tempChoiceInstructionAddress);
                } catch (err) {
                    reject(err);
                }
                
                if (!this.isRepeating) {
                    StoryStateHelper.resetAvailableChoices(this.storyState);

                    if (selectedChoice.saveToHistory) {
                        StoryStateHelper.addChoiceHistory(this.storyState, selectedChoice, getStateDiffs(beforeState, this.storyState), this.historySize);
                    }
                }                
            }

            StoryStateHelper.clearSelectedChoiceID(this.storyState);

            resolve();
        });
    }

    /**
     * Process the current scene. Updating speech, reprompt, variables as indicated by the scene.
     */
    private async processScene(sceneID?: string, sceneProperty?: string): Promise<any> {
        return new Promise<any> (async (resolve, reject) => {
            if (ACEDriver.debug) console.log("[INFO] Calling processScene.");

            let currentSceneID: string | null = StoryStateHelper.getCurrentSceneID(this.storyState);

            if (sceneID) {
                currentSceneID = sceneID;
            }

            if (ACEDriver.testing) {
                console.log("\n\nSCENE '" + currentSceneID + "'");
                console.log("........................");
            }
            
            let currentScene: Scene | undefined = undefined;
            if (currentSceneID != null) {
                try {
                    currentScene = await this.getSceneByID(currentSceneID || "");  
                } catch(err) {
                    reject(err);
                }
            } 

            if (!currentScene) {
                if (ACEDriver.debug) reject(`[WARN] Cannot find the Scene=[${currentSceneID}]`);
                else resolve();
                return;
            }
            
            this.stage.startNewScene();

            StoryStateHelper.clearRecap(this.storyState);

            for (let variation of currentScene.contents) {
                // evaluate body's conditional
                let conditionPassed: boolean = true;

                if (variation.condition && !variation.condition.startsWith("otherwise")) {
                    if (ACEDriver.debug) console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(variation.condition, null, 4));
                    
                    let substitution: any  = substituteSlotValues(variation.condition, this.storyState);
                    
                    if (ACEDriver.debug) console.log("[DEBUG] post-substitution condition= " + JSON.stringify(substitution, null, 4));
                    try {
                        if(!evalInContext(substitution.value, this)) {
                            conditionPassed = false;
                        }
                    } catch(err){ 
                        reject(err);
                        return;
                    }
                }

                if (!conditionPassed) {
                    if (ACEDriver.testing && variation.condition) console.log(`${padString("FAILED",8)}\t>${variation.condition}`);
                    continue;
                }

                if (ACEDriver.testing && variation.condition) console.log(`${padString("PASSED",8)}\t>${variation.condition}`);

                /*
                 * Narration
                 */
                let sceneNarration: AudioItem[] = [];

                if (variation.narration) {
                    let narrationText: string = substituteSlotValues(variation.narration, this.storyState, false).value
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ");

                    let narrationVariations: string[] = narrationText.split("||");

                    let selectedNarration: string = narrationVariations[Math.floor(Math.random() * narrationVariations.length)];
                    sceneNarration = this.buildAudioItemsFromSSML(selectedNarration);     
                } 

                /*
                 * Scene Directions
                 */
                try {
                    if (variation.sceneDirections && variation.sceneDirections.length > 0) {
                        let instructionSetAddress: string = currentSceneID + ":" + -1;

                        this.storyState.system_instruction_mem[instructionSetAddress] = (JSON.parse(JSON.stringify(variation.sceneDirections)));
                        
                        await this.performInstructions(instructionSetAddress);
                    }
                } catch(err) {
                    throw err;
                }

                if (sceneProperty && sceneProperty.trim().toLowerCase() == "reprompt" && this.stage.getRepromptSceneAudio().foreground.length > 0) {
                    sceneNarration = this.stage.getRepromptSceneAudio().foreground;
                }

                if (sceneProperty && sceneProperty.trim().toLowerCase() == "recap" && this.stage.getRecapSceneAudio().foreground.length > 0) {
                    sceneNarration = this.stage.getRecapSceneAudio().foreground;
                }

                this.stage.appendSceneSpeechForeground(sceneNarration);

                break; // Only one of the scene variations are played.
            }
            
            this.stage.closeScene();

            resolve();
        });
    }

    /**
     * Peform given list of scene directions in order.
     * 
     * @param directions Scene Directions to peform.
     * @return returns the resulting scene direction where all the variables are replaced by the actual values.
     */
    public async performInstructions(instructionAddress: string): Promise<boolean> {
        if (ACEDriver.debug) console.log(`[DEBUG] Calling performSceneDirections...`);

        let isTerminatingDirection: boolean = false;
        
        let visualAlreadyDefined: boolean = false;

        let directions: SceneDirection[] = this.storyState.system_instruction_mem[instructionAddress];

        for (let lineNumber = 0 ; lineNumber < directions.length; lineNumber++) {
            let parameters: {[key: string]: any;} = JSON.parse(JSON.stringify(directions[lineNumber].parameters));
            let type: SceneDirectionType = directions[lineNumber].directionType;

            for (let paramName of Object.keys(parameters)) {
                if (typeof(parameters[paramName]) == 'string') {

                    if(type !== SceneDirectionType.REPROMPT && paramName != "condition") {
                        parameters[paramName] = substituteSlotValues(parameters[paramName], this.storyState, false).value;
                    } else {
                        parameters[paramName] = substituteSlotValues(parameters[paramName], this.storyState).value;
                    }
                }
            }

            switch(type) {
            case SceneDirectionType.CUSTOM: {
                
                if (ACEDriver.testing) console.log(`${padString("CUSTOM",8)}\t> calling custom instruction with:\n${JSON.stringify(parameters, null, 4)}`);

                for (let extension of this.customExtensions) {
                    if (isInstructionExtension(extension)) {
                        const customInstructionName: string = parameters.customName;

                        if ((extension as any)[customInstructionName]) {
                            await (extension as any)[customInstructionName]({
                                    instructionName:parameters.customName,
                                    instructionParameters: parameters,
                                    playStage: this.stage,
                                    storyAccessor: this.storyAccessor,
                                    storyState: this.storyState
                                });
                        }
                    } else {
                        continue;
                    }
                }

                break;
            }
            case SceneDirectionType.SLOT: {
                let variableName: string = parameters.variableName;
                let slotType: string = parameters.variableType;

                if (!this.storyState[variableName] || typeof this.storyState[variableName] != 'object') {
                    this.storyState[variableName] = {};
                }

                this.storyState[variableName].type = slotType;

                if (ACEDriver.testing) console.log(`${padString("SLOT",8)}\t>'${variableName}' as ${slotType}`);
                break;
            }
            case SceneDirectionType.BOOKMARK: {
                let bookmarkName: string = parameters.variableName;
                let targetName: string | null = parameters.variableValue;

                if (!targetName) {
                    targetName = StoryStateHelper.getCurrentSceneID(this.storyState);
                }
 
                if (targetName == null) {
                    throw "[ACEDriver Error] target is not defined for the bookmark command.";
                }

                this.storyState[bookmarkName] = {
                    type: 'sceneID',
                    value: targetName
                }

                if (ACEDriver.testing) console.log(`${padString("BOOKMARK",8)}\t>'${bookmarkName}' as ${targetName}`);
                break;

            }
            case SceneDirectionType.CHOICE: {
                let choiceID: string = createHash('md5').update(JSON.stringify(parameters.utterances).trim().toLowerCase()).digest('hex');
                
                let choiceInstructions: SceneDirection[] = parameters.directions ? (JSON.parse(JSON.stringify(parameters.directions))) : [];

                let choice: Choice = {
                    id: choiceID,
                    sceneDirections: choiceInstructions,
                    utterances: parameters.utterances,
                    saveToHistory: false//parameters.saveToHistory && parameters.saveToHistory.trim().toLowerCase() == 'true'? true: false
                }

                if (parameters.narration) {
                    choice.narration = parameters.narration;
                }

                StoryStateHelper.enqueueAvailableChoice(this.storyState, choice);

                if (ACEDriver.testing) console.log(`${padString("CHOICE",8)}\t> Register ChoiceID=[${choiceID}] for expected input '${parameters.utterances}' for instructions ${JSON.stringify(choiceInstructions, null, 4)}`);

                break;
            }
            case SceneDirectionType.CONDITION: {
                let conditionPassed: boolean = true;
                
                let conditionString: string = parameters.condition;

                if (ACEDriver.debug) console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(conditionString, null, 4));
                    
                let substitution: any  = substituteSlotValues(conditionString, this.storyState);

                if (ACEDriver.debug) console.log("[DEBUG] post-substitution condition= " + JSON.stringify(substitution, null, 4));

                try {
                    if(!evalInContext(substitution.value, this)) {
                        conditionPassed = false;
                    }
                } catch(err){ 
                    throw err;
                }

                if (!conditionPassed) {
                    if (ACEDriver.testing && conditionString) console.log(`${padString("FAILED",8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                } else {
                    if (ACEDriver.testing && conditionString) console.log(`${padString("PASSED",8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                    let conditionInstructionAddress: string = instructionAddress + ":" + lineNumber;
                    
                    if (parameters.directions && parameters.directions.length > 0) {
                        let savingInstructions: SceneDirection[] = (JSON.parse(JSON.stringify(parameters.directions)))
                        .concat(directions.slice(lineNumber + 1));

                        this.storyState.system_instruction_mem[conditionInstructionAddress] = savingInstructions
        
                        await this.performInstructions.call(this, conditionInstructionAddress);

                        isTerminatingDirection = true;
                    }
                }

                break;
            }
            case SceneDirectionType.GO_TO: {
                let destinationPage: string = parameters.target;

                if (this.storyState[destinationPage] && this.storyState[destinationPage].type == 'sceneID') {
                    this.playQueue.push({
                        sceneID: this.storyState[destinationPage].value,
                        property: parameters.targetSceneProperty || "narration"
                    });

                } else {
                    this.playQueue.push({
                        sceneID: destinationPage.toLowerCase(),
                        property: parameters.targetSceneProperty || "narration"
                    });
                }

                isTerminatingDirection = true;

                if (ACEDriver.testing) console.log(`${padString("GO TO",8)}\t>scene '${destinationPage}'`);
                break;
            }
            case SceneDirectionType.SAVE_AND_GO: {
                let destinationPage: string = parameters.target.toLowerCase();
                
                let savingInstructions: SceneDirection[] = directions.slice(lineNumber + 1);
                
                let savingAddress: string = instructionAddress + ":" + lineNumber;

                this.storyState.system_instruction_mem[savingAddress] = savingInstructions;
                if (!this.storyState.system_call_stack) {
                    this.storyState.system_call_stack = [];
                }

                this.storyState.system_call_stack.push(savingAddress);

                if (ACEDriver.testing) console.log(`${padString("CALL",8)}\t>scene '${destinationPage}'`);
                
                this.playQueue.push({
                    sceneID: destinationPage,
                    property: parameters.targetSceneProperty || "narration"
                });

                isTerminatingDirection = true;

                break;
            }
            case SceneDirectionType.RETURN: {
                if (this.storyState.system_call_stack && this.storyState.system_call_stack.length > 0) {
                    let returnAddress: string = this.storyState.system_call_stack.splice(-1, 1)[0];

                    if (ACEDriver.testing) console.log(`${padString("RETURN",8)}\t> Returning to address ${returnAddress}.'`);

                    let poppingSceneID: string = returnAddress.split(":")[0];
                    StoryStateHelper.setCurrentSceneID(this.storyState, poppingSceneID);
                    await this.performInstructions.call(this, returnAddress);
                } else {
                    if (ACEDriver.testing) console.log(`${padString("RETURN",8)}\t> There is instructions to return to.'`);
                }

                isTerminatingDirection = true;

                break;
            }
            case SceneDirectionType.RESTART: {
                await this.resetStory();
                this.playQueue.push({
                    sceneID: BuiltInScenes.StartScene,
                    property: parameters.targetSceneProperty || "narration"
                });

                if (ACEDriver.testing) console.log(`${padString("RESTART",8)}\t> Refresh and restart the story.`);

                isTerminatingDirection = true;
                break;
            }
            case SceneDirectionType.REPEAT: {
                if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                    this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                    this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);

                    if (ACEDriver.testing) console.log(`${padString("REPEAT",8)}\t> Repeating previously heard speech:\n${JSON.stringify(this.storyState.system_prevSpeech, null, 4)}\nreprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                } else {
                    if (ACEDriver.testing) console.log(`${padString("REPEAT",8)}\t> Nothing to repeat.'`);
                }

                this.isRepeating = true;
                isTerminatingDirection = true;

                break;  
            }
            case SceneDirectionType.REPEAT_REPROMPT: {
                if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                    this.stage.setStageSpeechAudioSequence(this.stage.getStageRepromptAudioSequence().concat(this.storyState.system_prevReprompt));
                    this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);

                    if (ACEDriver.testing) console.log(`${padString("RE-REPROMPT",8)}\t> Repeating previously heard reprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                } else {
                    if (ACEDriver.testing) console.log(`${padString("RE-REPROMPT",8)}\t> Nothing to reprompt.'`);
                }

                this.isRepeating = true;
                isTerminatingDirection = true;

                break;
            }
            case SceneDirectionType.BACK: {
                let countBack: number = parameters.count + 1;

                if (!this.storyState.system_originStack || this.storyState.system_originStack.length == 0) {  
                    if (ACEDriver.testing) console.log(`${padString("BACK",8)}\t>There is no scene to go back to.`);
                } else {
                    let transitionStack: string[] = JSON.parse(JSON.stringify(this.storyState.system_originStack));

                    let destinationScene: any = undefined;

                    while (countBack-- > 0 && transitionStack.length > 0) {
                        destinationScene = transitionStack.splice(-1, 1)[0];
                    }

                    this.playQueue.push(destinationScene);

                    this.storyState.system_originStack = transitionStack;
                    if (ACEDriver.testing) console.log(`${padString("BACK",8)}\t> back count=${parameters.count} to scene '${JSON.stringify(destinationScene)}'`);
                }

                isTerminatingDirection = true;

                break;
            }
            case SceneDirectionType.RECAP: {
                let recapMessage: string[] = substituteSlotValues(parameters.message, this.storyState, false).value
                    .replace(/\n/g, " ")
                    .replace(/[\s]+/g, " ")
                    .split("||");

                let selectedRecap: string = recapMessage[Math.floor(Math.random() * recapMessage.length)];

                if (selectedRecap.trim().length > 0) {
                    this.stage.appendSceneRecapForeground(this.buildAudioItemsFromSSML(selectedRecap.replace(/\n/g, ' ').replace(/[\s]+/g, ' ')));
    
                    if (ACEDriver.testing) console.log(`${padString("RECAP",8)}\t>'${selectedRecap}'`);    
                } else {
                    if (ACEDriver.testing) console.log(`${padString("RECAP",8)}\t>'Nothing to set as recap message.'`);    
                }

                break;
            }
            case SceneDirectionType.END: {
                StoryStateHelper.setEndingReached(this.storyState, true);
                await this.resetStory();
                this.isRepeating = true;
                
                if (ACEDriver.testing) console.log(`END`);

                isTerminatingDirection = true;
                break;
            }
            case SceneDirectionType.PAUSE: {
                this.isPausing = true;
                if (ACEDriver.testing) console.log(`PAUSE`);

                isTerminatingDirection = true;
                break;
            }
            case SceneDirectionType.BGM: {
                let bgmURL: string = parameters.audioURL;
        
                this.stage.appendSceneSpeechBackground(
                    this.buildAudioItemsFromSSML(`<audio src='${bgmURL}' delay='${parameters.delayMs||""}' volume='${parameters.volume||""}' blend='${parameters.blend}'/>`));

                if (ACEDriver.testing) console.log(`${padString("BGM",8)}\t>${bgmURL}`);
                break;
            }
            case SceneDirectionType.CLEAR: {
                let attributeName: string = parameters.variableName;

                if (attributeName.trim() == "*") {
                    attributeName = "";

                    for (let key of Object.keys(this.storyState)) {
                        if (!key.startsWith("system_")) {
                            attributeName += `${key} ; `;
                            delete this.storyState[key];
                        }
                    }

                } else {
                    delete this.storyState[attributeName];
                }

                if (ACEDriver.testing) console.log(`${padString("CLEAR",8)}\t>'${attributeName}'`);
                break;
            }
            case SceneDirectionType.ADD_TO_INVENTORY: {
                let item: string = parameters.itemName;
                let listName: string = parameters.variableName;

                if (!this.storyState[listName]){ 
                    this.storyState[listName] = {};
                }

                if (!this.storyState[listName][item]) {
                    this.storyState[listName][item] = 0;
                }

                this.storyState[listName][item] ++;

                if (ACEDriver.testing) console.log(`${padString("ADD INVENTORY",8)}\t>'${item}' to '${listName}'`);
                break;
            }
            case SceneDirectionType.ADD_ITEM: {
                let item: string = parameters.itemName;
                let listName: string = parameters.variableName;
                let sizeLimit: string = parameters.size || "-1";

                if (!this.storyState[listName]){ 
                    this.storyState[listName] = [];
                }

                this.storyState[listName].push(item);

                let size: number = parseInt(sizeLimit, 10);
                if (size > 0 && this.storyState[listName].length > size) {
                    this.storyState[listName].splice(0, this.storyState[listName].length - size);
                }

                if (ACEDriver.testing) console.log(`${padString("ADD ITEM",8)}\t>'${item}' to '${listName}'`);
                break;
            }
            case SceneDirectionType.GET_TIME: {
                let currentTime: number = new Date().getTime();

                this.storyState.system_return = currentTime;

                if (ACEDriver.testing) console.log(`${padString("GET TIME",8)}\t>${currentTime}`);
            }
            case SceneDirectionType.REMOVE_ITEM: {
                let item: string = parameters.itemName;
                let listName: string = parameters.variableName;

                if (this.storyState[listName] && typeof this.storyState[listName].length == 'number') {
                    let deletingIndex: number = -1; 
                    for (let i = 0; i < this.storyState[listName].length; i ++) {
                        if (this.storyState[listName][i] == item) {
                            deletingIndex = i;
                            break;
                        }
                    }

                    if (deletingIndex >= 0) {
                       let removeResult: any = this.storyState[listName].splice(deletingIndex, 1)[0];
                       this.storyState.system_return = removeResult;
                    }
                } else if (this.storyState[listName] && typeof this.storyState[listName].length == 'undefined') {
                    if (typeof this.storyState[listName][item] == 'number' && this.storyState[listName][item] > 0) {
                        this.storyState[listName][item] --;
                    } else if (typeof this.storyState[listName][item] != 'number') {
                        delete this.storyState[listName][item];
                    }
                }

                if (ACEDriver.testing) console.log(`${padString("DEL ITEM",8)}\t>'${item}' from '${listName}'`);
                break;
            }
            case SceneDirectionType.REMOVE_FIRST: {
                let listName: string = parameters.variableName;

                if (this.storyState[listName]) {
                    let removeResult: any = this.storyState[listName].splice(0, 1)[0]
                    
                    this.storyState.system_return = removeResult;   
                }

                if (ACEDriver.testing) console.log(`${padString("DEL ITEM",8)}\t>FIRST from '${listName}'`);
                break;
            }
            case SceneDirectionType.REMOVE_LAST: {
                let listName: string = parameters.variableName;

                if (this.storyState[listName]) {
                    let removeResult: any = this.storyState[listName].splice(this.storyState[listName].length - 1, 1); 
                    
                    this.storyState.system_return = removeResult;
                }

                if (ACEDriver.testing) console.log(`${padString("DEL ITEM",8)}\t>LAST from '${listName}'`);
                break;
            }
            case SceneDirectionType.FLAG: {
                let variableName: string = parameters.variableName;

                this.storyState[variableName] = true;

                if (ACEDriver.testing) console.log(`${padString("FLAG",8)}\t>'${variableName}'`);
                break;
            }
            case SceneDirectionType.UNFLAG: {
                let variableName: string = parameters.variableName;

                this.storyState[variableName] = false;

                if (ACEDriver.testing) console.log(`${padString("UNFLAG",8)}\t>'${variableName}'`);
                break;
            }
            case SceneDirectionType.SET: {
                let variableName: string = parameters.variableName;
                let value: number | any = parameters.variableValue == "undefined"? 0: parseFloat(parameters.variableValue);

                if (parameters.variableValue.length === 0) {
                    value = "";
                } else if (isNaN(parameters.variableValue)) {
                    value = parameters.variableValue;

                    if (value == 'true') {
                        value = true;
                    } else if (value == 'false') {
                        value = false;
                    }
                }
                

                if (this.storyState[variableName] == undefined) {
                    this.storyState[variableName] = 0;
                }

                this.storyState[variableName] = value;

                if (ACEDriver.testing) console.log(`${padString("SET",8)}\t>'${variableName}' as ${value}`);
                break;
            }
            case SceneDirectionType.REDUCE: {
                let variableName: string = parameters.variableName;
                let value: number = parseFloat(parameters.variableValue);

                if (isNaN(parameters.variableValue)) {
                    value = 0;
                }

                if (isNaN(this.storyState[variableName])) {
                    this.storyState[variableName] = 0;
                }

                this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) - value) * 100) / 100;
                if (ACEDriver.testing) console.log(`${padString("REDUCE",8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                break;
            }
            case SceneDirectionType.INCREASE: {
                let variableName: string = parameters.variableName;
                let value: number = parseFloat(parameters.variableValue);

                if (isNaN(parameters.variableValue)) {
                    value = 0;
                }

                if (isNaN(this.storyState[variableName])) {
                    this.storyState[variableName] = 0;
                }

                this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) + value) * 100) / 100;

                if (ACEDriver.testing) console.log(`${padString("INCREASE",8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                break;
            }
            case SceneDirectionType.MULTIPLY: {
                let variableName: string = parameters.variableName;
                let value: number = parseFloat(parameters.variableValue);

                if (isNaN(parameters.variableValue)) {
                    value = 0;
                }

                if (isNaN(this.storyState[variableName])) {
                    this.storyState[variableName] = 0;
                }

                this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) * value) * 100) / 100;

                if (ACEDriver.testing) console.log(`${padString("MULTIPLY",8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                break;
            }
            case SceneDirectionType.DIVIDE: {
                let variableName: string = parameters.variableName;
                let value: number = parseFloat(parameters.variableValue);

                if (isNaN(parameters.variableValue)) {
                    value = 0;
                }

                if (isNaN(this.storyState[variableName])) {
                    this.storyState[variableName] = 0;
                }

                this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) / value) * 100)/100;

                if (ACEDriver.testing) console.log(`${padString("DIVIDE",8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                break;
            }
            case SceneDirectionType.ROLL: {
                let rollEval: string = parameters.diceString;

                this.evaluateDiceRoll(rollEval);

                if (ACEDriver.testing) console.log(`${padString("ROLL",8)}\t>'${rollEval}'`);
                break;
            }
            case SceneDirectionType.REPROMPT: {
                let repromptMessages: string[] = substituteSlotValues(parameters.message, this.storyState, false).value
                    .replace(/\n/g, " ")
                    .replace(/[\s]+/g, " ")
                    .split("||");

                let selectedReprompt: string = repromptMessages[Math.floor(Math.random() * repromptMessages.length)];
                this.stage.appendSceneRepromptForeground(
                    this.buildAudioItemsFromSSML(selectedReprompt.replace(/\n/g, ' ').replace(/[\s]+/g, ' ')));

                if (ACEDriver.testing) console.log(`${padString("REPROMPT",8)}\t>'${selectedReprompt}'`);
                break;
            }
            case SceneDirectionType.VISUALS: {                
                if (visualAlreadyDefined) {
                    let currentVisuals: VisualOptions[] = this.stage.getStageVisualOptions() || [];
                    currentVisuals[currentVisuals.length - 1] = <VisualOptions>parameters;

                    this.stage.setStageVisualOptions(currentVisuals);
                } else {
                    visualAlreadyDefined = true;
                    
                    this.stage.appendStageVisuals(<VisualOptions>parameters);
                }

                break;
            }
            default: {
                throw "[STORY - SYNTAX ERROR] the story effect is not recognized.\nline number=[" 
                    + lineNumber + "]\nline content=["
                    + JSON.stringify(directions[lineNumber], null, 4) + "]\n"
                    + "pageID=[" + StoryStateHelper.getCurrentSceneID(this.storyState) + "]";
            }
            }
 
            if (isTerminatingDirection || lineNumber == directions.length - 1) {
                delete this.storyState.system_instruction_mem[instructionAddress];
                break;
            }
        }

        return isTerminatingDirection;        
    }

    /**
     * Get the scene object of the currently driving story givene the scene ID.
     * @param sceneID scene ID
     */
    public async getSceneByID(sceneID: string): Promise<Scene> {
        let adjustedSceneID: string = sceneID.trim().toLowerCase();

        let drivingStoryID: string = await this.storyAccessor.getStoryID();

        if (!ACEDriver.STORY_METADATA_CACHE[drivingStoryID]) {
            let id2Page: {[key: string]: Scene} = {};

            for (let scene of await this.storyAccessor.getAllScenes()) {
                id2Page[scene.id.toLowerCase()] = scene;
            }

            ACEDriver.STORY_METADATA_CACHE[drivingStoryID] = id2Page;
        }

        if (ACEDriver.STORY_METADATA_CACHE[drivingStoryID][adjustedSceneID] || BuiltInScenes.PauseScene.toLowerCase() == adjustedSceneID ||
            BuiltInScenes.ResumeScene.toLowerCase() == adjustedSceneID) {
            return ACEDriver.STORY_METADATA_CACHE[drivingStoryID][adjustedSceneID];
        } else {
            throw `[ERROR] Cannot find the scene ${adjustedSceneID} from the story=${drivingStoryID}.`; 
        }

    }

    public clearMetadataCache() {
        ACEDriver.STORY_METADATA_CACHE = {};
    }

    /**
     * Compute a dice roll given a standard dice string.
     * 
     * @param diceString 
     */
    private evaluateDiceRoll(diceString: string) {        
        let diceRegex: RegExp = /([\d])d([\d]*)+[k]?([\d]*)/gi
    
        let diceMatch: RegExpExecArray|null = diceRegex.exec(diceString);
    
        let rollResults: number[] = [];
        while (diceMatch != null) {
            let rollResult: number = 0;
            let diceCount: number = parseInt(diceMatch[1], 10);
            let faceCount: number = parseInt(diceMatch[2], 10);
            let selectCount: number = parseInt(diceMatch[3], 10);
    
            let rolls: number[] = [];
            for (let i = 0; i < diceCount; i++) {
                if (ACEDriver.probabilityOff) {
                    rolls.push((faceCount + 1) / 2);
                } else {
                    rolls.push(Math.floor(Math.random() * faceCount) + 1);
                }
            }
    
            let sumCount: number = rolls.length;
            if (selectCount) {
                rolls.sort().reverse(); //descending sort
                sumCount = selectCount
            } 
            
            for (let i = 0 ; i < sumCount; i++) {
                rollResult += rolls[i];
            }
    
            rollResults.push(rollResult);
    
            diceMatch = diceRegex.exec(diceString);
        }
    
        let diceMatchReplace: string = diceString.replace(diceRegex, () => {
            return String(rollResults.splice(0, 1)[0]);
        });
    
        let rollFinalEval: any = eval(diceMatchReplace);
        if (ACEDriver.debug) console.log("[DEBUG] Roll result for the entire dice configuration=[" + diceMatchReplace + "], result=[" + rollFinalEval + "]" );
    
        this.storyState.rollResult = rollFinalEval;
    }

    /**
     * Given a string of ssml (supported with voice, audio tags), create an array of Audio Items.
     * @param ssml string of ssml text
     */
    private buildAudioItemsFromSSML(ssml: string): AudioItem[] {
        let dialogue: string = ssml.trim();
        
        let partitioningRegex: RegExp = /(<audio[\s]+src=[\"'][^><]+?[\"'][\s]*?\/>)|(<voice[\s]+[\s\S]+?<\/voice>)|([\s\S]+?)(?=<audio|<voice|$)/g;
    
        let partitionMatch: string[] | null = partitioningRegex.exec(dialogue);
    
        let audioItems: AudioItem[] = [];
        while (partitionMatch != null) {
            
            if (partitionMatch[1] && partitionMatch[1].trim().length > 0) {
                let audioTagParse: RegExp = /\b(src|volume|delay|blend)=[\"']([\S]+?)[\"']/g;
    
                let audioTagText: string = partitionMatch[1];
                let audioTagMatch: any = audioTagParse.exec(audioTagText);
    
                let volume: number = 1.0;
                let delay: number = 0;
                let content: string = "";
                let blendOption: string = AudioBlendOption.TRIM;
                while (audioTagMatch != null) {

                    if (!audioTagMatch[2] || audioTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    } else if (audioTagMatch[1].trim() == "src") {
                        content = audioTagMatch[2]
                    } else if (audioTagMatch[1].trim() == "volume") {
                        volume = parseFloat(audioTagMatch[2]);
                    } else if (audioTagMatch[1].trim() == "delay") {
                        delay = parseInt(audioTagMatch[2]);
                    } else if (audioTagMatch[1].trim() == "blend") {
                        blendOption = audioTagMatch[2];
                    }

                    audioTagMatch = audioTagParse.exec(audioTagText);
                }
    
                audioItems.push({
                    type: AlexaAudioType.AUDIO,
                    content: content,
                    volume: volume,
                    delay: delay,
                    options: {
                        blend: blendOption
                    }
                });
            } else if (partitionMatch[2] && partitionMatch[2].trim().length > 0) {   
                
                let pollyTagParse: RegExp = /<voice[\s]+[\s\S]*?(name|volume|delay|pitch|rate)=[\"']([\S]+?)[\"'][\s\S]*?>/g;
    
                let pollyTagText: string = partitionMatch[2];
                
                let pollyTagMatch: any = pollyTagParse.exec(pollyTagText);
    
                let name: string = "";
                let volume: number = 3.0;
                let delay: number = 0;
                let rate: string = "";
                let pitch: string = "";
                while (pollyTagMatch != null) {
                    if (!pollyTagMatch[2] || pollyTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    } else if (pollyTagMatch[1].trim() == "name") {
                        name = pollyTagMatch[2];
                    } else if (pollyTagMatch[1].trim() == "volume") {
                        volume = parseFloat(pollyTagMatch[2]);
                    } else if (pollyTagMatch[1].trim() == "delay") {
                        delay = parseInt(pollyTagMatch[2]);
                    } else if (pollyTagMatch[1].trim() == "pitch") {
                        pitch = pollyTagMatch[2];
                    } else if (pollyTagMatch[1].trim() == "rate") {
                        rate = pollyTagMatch[2];
                    }
    
                    pollyTagMatch = pollyTagParse.exec(pollyTagText);
                }
    
                let contentMatch: any = />([\s\S]*?)<\/voice/g.exec(pollyTagText);
    
                audioItems.push({
                    type: AlexaAudioType.POLLY,
                    content: contentMatch[1],
                    volume: volume,
                    delay: delay,
                    options: {
                        pitch: pitch,
                        rate: rate,
                        voice: name
                    }
                });
            } else if (this.isPollyAsDefault) {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: AlexaAudioType.POLLY,
                        content: partitionMatch[3],
                        volume: this.volume,
                        delay: 0,
                        options: {
                            pitch: this.pitch,
                            rate: this.rate,
                            voice: this.voiceName
                        }
                    });
                }
            } else {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: AlexaAudioType.TEXT,
                        content: partitionMatch[3],
                        volume: 3.0,
                        delay: 0
                    });
                }
            }
    
            partitionMatch = partitioningRegex.exec(dialogue);
        }
    
        return audioItems;
    }
}

function substituteSlotValues(line : string, eventParams : any, isCondition : boolean = true) : any {
    // Now substitute in all the {variable1}, {variable2}, etc. fields
    let regex = /\{([^{}]*?)\}/g;

    let matches = line.match(regex);
    
    let allSlotsFilled : boolean = true;

    while(matches) {
        let slotsToFill : any = {};

        // Find all the replacement slot names
        for(const match of matches) {
            slotsToFill[match] = 1;
        }

        let keys = Object.keys(slotsToFill);
        
        for(let keyOriginal of keys) {
            // Remove the opening and closing { } signs and single quotes within the key
            let key = keyOriginal.substr(1, keyOriginal.length - 2).replace(/\'/g,"");

            line = line.replace(new RegExp("\\{" + keyOriginal.substr(1, keyOriginal.length - 2) + "\\}","g"), "{" + key + "}");

            if (key.split(".").length > 1 ) {
                let splitKey:string[] = key.split(".");
                let crawl:any = eventParams[splitKey[0].replace(/'/g, "")];
                for (let i = 1; i < splitKey.length; i++) {

                    if (crawl != undefined) {
                        crawl = crawl[splitKey[i]];

                        if(crawl != undefined && i == splitKey.length - 1) {
                            let find = "\\{" + key + "\\}";			

                            let re = new RegExp(find, 'g');
                    
                            let value: any = crawl;
        
                            line = line.replace(re, value);
                        } if (crawl == undefined) {
                            let find = "\\{" + key + "\\}";			

                            let re = new RegExp(find, 'g');

                            let value: any = crawl;

                            line = line.replace(re, "undefined");
                        }
                    } else {
                        let find = "\\{" + key + "\\}";			

                        let re = new RegExp(find, 'g');

                        line = line.replace(re, "false");

                        allSlotsFilled = true;
                    }
                }
            } else {
                if(eventParams[key.replace(/'/g, "")] != undefined) {
                    let find = "\\{" + key + "\\}";			

                    let re = new RegExp(find, 'g');
            
                    let value: any = eventParams[key.replace(/'/g, "")];
                    if (isNaN(value) && isCondition) {
                        value =  "'" + value + "'";
                    }

                    line = line.replace(re, value);

                } else {
                    let find = "\\{" + key + "\\}";			

                    let re = new RegExp(find, 'g');

                    line = line.replace(re, "false");

                    allSlotsFilled = true;
                }
            }
        }		

        matches = line.match(regex);
    }

    return { value: line, allSlotsFilled : allSlotsFilled};
}

// Evalute the given string given the limited context given
function evalInContext(js : string, context : any) {
    //# Return the results of the in-line anonymous function we .call with the passed context
    return function() { return eval(js.replace(/\bundefined\b/g, "false")); }.call(context);
}

/*
`
<prosody rate="${rate}" pitch="${pitch}">
<amazon:effect name="drc" vocal-tract-length="+0%">
<amazon:auto-breaths>
${partitionMatch[0]}
</amazon:auto-breaths>
</amazon:effect>
</prosody> 

audioBuilder.addPollySequence({name: voiceName, text: textWithVoiceMarkup, delayMs: 100, volume: volume});
let outputUrl = await buildAudio(audioBuilder);

resultDialogue += AlexaUtil.wrapAudioTag(outputUrl);
`*/

function check(pre:string, before:any, after:any) {
    let padSize: any = process.env.ABC_DEBUG_PAD_SIZE || 20;

    if ((before === undefined && after !== undefined) || (before !== undefined && after === undefined)) {
        console.log(`[${padString(pre,padSize)}\t|\t${padString(JSON.stringify(before),padSize)}\t>>>\t${padString(JSON.stringify(after), padSize)}]`);
        return;
    }

    if (after == undefined || after == null) {
        return;
    }

    for (let key of Object.keys(after)) {
        if (typeof after[key] === "object") {
            check(pre + "." +  key, before[key], after[key]);
        } else {
            if (before[key] !== after[key]) {
                if (pre.length > 0) {
                    console.log(`[${padString(pre + "." + key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                } else {
                    console.log(`[${padString(key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                }
            }
        }
    }
    return;
}

function getStateDiffs(before:any, after:any): StateDiffItem[] {
    let stateDiffs: StateDiffItem[] = [];
    // check removed items
    for (let key of Object.keys(before)) {
        if (before[key] && after[key] === undefined) {
            stateDiffs.push({
                itemName: key,
                beforeValue: JSON.parse(JSON.stringify(before[key])),
                afterValue: undefined
            });
        }
    }

    for (let key of Object.keys(after)) {
        if (JSON.stringify(after[key]) != JSON.stringify(before[key])) {
            stateDiffs.push({
                itemName: key,
                beforeValue: before[key]? JSON.parse(JSON.stringify(before[key])) : undefined,
                afterValue: JSON.parse(JSON.stringify(after[key]))
            });
        }
    }

    return stateDiffs;
}

function padString(incomingText: string, length: number) {
    let text: string = String(incomingText);

    let result: string = text;
    if (text.length < length) {
        for (let i = 0 ; i <= length - text.length; i ++) {
            result += " ";
        }
    } else {
        result = "~" + result.substring(text.length - length);
    }
    return result;
}