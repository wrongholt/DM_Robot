import { StoryMetadata, ABCImportPlugin, SceneDirection, SceneDirectionType } from '../aceEntities/interfaces';
import { InteractionModelBuilder, IIntentBuilder, ISlotBuilder, ICustomSlotTypeBuilder } from '@alexa-games/sfb-util';
import { BUILT_IN_INTENT_UTTERANCES } from './BuiltInIntents';

export class ModelBaker {
    static async bake(autoIntentGrouping: boolean, story: StoryMetadata, importer: ABCImportPlugin, _locale: string = 'en'): Promise<any> {
        let locale: string = _locale;
        if (!BUILT_IN_INTENT_UTTERANCES[locale] && BUILT_IN_INTENT_UTTERANCES[locale.split("-")[0]]) {
            locale = locale.split("-")[0];
        }

        let choiceGrouping: {[key: string]: string} = {};
    
        for (let intentName in BUILT_IN_INTENT_UTTERANCES[locale]) {
            for (let utterance of BUILT_IN_INTENT_UTTERANCES[locale][intentName]) {
                choiceGrouping[utterance.toLowerCase()] = intentName;
            }
        }
        let slotTracker: any = {};

        if (autoIntentGrouping) {
            let slotCount = 0;

            for (let scene of story.scenes) {            
                for (let content of scene.contents) {
                    if (content.sceneDirections) {
                        let directionQueue: SceneDirection[] = JSON.parse(JSON.stringify(content.sceneDirections));
                        
                        let choiceDirections: SceneDirection[] = [];

                        while (directionQueue.length > 0) {
                            let verifyingDirection: SceneDirection = directionQueue.splice(0, 1)[0];
                            
                            if (verifyingDirection.directionType === SceneDirectionType.SLOT) {
                                let name: string = verifyingDirection.parameters.variableName;
                                let type: string = verifyingDirection.parameters.variableType;

                                slotTracker[name] = type;

                            } else if (verifyingDirection.directionType === SceneDirectionType.CHOICE) {                                    
                                verifyingDirection.parameters.utterances = JSON.parse(JSON.stringify(verifyingDirection.parameters.utterances).replace(/{([\s\S]+?)(?: as ([\s\S]+?))?}/g, function(match: any, p1: string, p2: string) {
                                    if (p1 && !p2 && slotTracker[p1]) {
                                        return `{${slotTracker[p1]} as ${p1}}`;
                                    }

                                    return match;
                                }));

                                choiceDirections.push(verifyingDirection);
                            } else if (verifyingDirection.directionType === SceneDirectionType.CONDITION) {
                                directionQueue = directionQueue.concat(verifyingDirection.parameters.directions);
                            }
                        }

                        convertDecisions2Groups.call(this, choiceGrouping, choiceDirections, function(choice: any) {
                            return choice.parameters.utterances;
                        }, locale, slotCount);
                    }
                }
            }
        }

        for (let scene of story.scenes) {            
            for (let bodyContent of scene.contents) {
                if (bodyContent.sceneDirections) {
                    for (let directionIndex in bodyContent.sceneDirections) {
                        if (bodyContent.sceneDirections[directionIndex].parameters.utteranceGrouped) {
                            delete bodyContent.sceneDirections[directionIndex].parameters.utteranceGrouped;
                        }
                    }
                }
            }
        }

        return buildVoiceModelWithGrouping(choiceGrouping, "", importer, locale);
    }
}

const SLOT_VERSION_BASE: number = 26;
const A_CHAR_CODE: number = 'a'.charCodeAt(0);

export function numberToAlphabetCounting(i: number) {
    const base26Count = i.toString(SLOT_VERSION_BASE);

    const alphaBaseCount = base26Count.replace(/./g, (match): string => {
        if (isNaN(parseInt(match, 10))) {
            return String.fromCharCode(match.charCodeAt(0) + 10);
        } else {
            return String.fromCharCode(A_CHAR_CODE + parseInt(match, 10));
        }
    });

    return alphaBaseCount;
}

function convertDecisions2Groups(grouping: {[key:string] : string}, choices: any[], parsingFunction: (choice: any) => string[], locale: string, slotCount: number): void {
    for (let intentName in BUILT_IN_INTENT_UTTERANCES[locale]) {
        for (let utterance of BUILT_IN_INTENT_UTTERANCES[locale][intentName]) {
            grouping[utterance] = intentName;
        }
    }

    let crossReference: {[key:string] : number} = {};

    let decisionIndex: number = 0;
    for (let choice of choices) {
        let words: string[] = parsingFunction(choice);
        let groupNameToApply: string | undefined = undefined;

        // find already existing group
        for (let word of words) {            
            if (word != "$auto" && word != "*" ) {
                let groupName = grouping[word.trim()];
                
                if ((groupName && groupName.startsWith("AMAZON.")) || BUILT_IN_INTENT_UTTERANCES[locale][word.trim()]) {
                    continue;
                } else if (groupName) {
                    if (crossReference[groupName] != undefined && crossReference[groupName] < decisionIndex) {
                        grouping[word.trim()] = `${numberToAlphabetCounting(slotCount)}Slot`;
                        slotCount++;
                    } else {
                        groupNameToApply = groupName;
                        crossReference[groupNameToApply] = decisionIndex;
                    }
                } else if (!groupNameToApply) {
                    groupNameToApply = `${numberToAlphabetCounting(slotCount)}Slot`;
                    slotCount++;
                    crossReference[groupNameToApply] = decisionIndex;
                }
            }
        }

        for (let word of words) {
            if (word != "$auto") {
                if (!grouping[word.trim()] && groupNameToApply) {
                    grouping[word.trim()] = groupNameToApply;
                }
            }
        }

        decisionIndex++;
    }
}

function buildVoiceModelWithGrouping(grouping: {[key: string]: string}, invocationName: string, importer: ABCImportPlugin, locale: string): any {
    let groupToContent: {[key:string]: string[]} = {};
    for (let key in grouping) {
        let groupName: string = grouping[key];
        let wordValue: string = key.trim();

        if (!groupToContent[groupName]) {
            groupToContent[groupName] = [];
        }

        groupToContent[groupName].push(wordValue);
    }

    let interactionModelBuilder: InteractionModelBuilder = new InteractionModelBuilder();

    interactionModelBuilder.withIntent((customIntentBuilder: IIntentBuilder) => {
            customIntentBuilder.withIntentName("FlexibleAnswerIntent");

            let alreadyUsedSlotName: any = {};
            let alreadyCreatedSlotType: any = {};

            for (let slotName in groupToContent) {
                let customValues: string[] = [];
                let utteranceStructures: string[] = [];

                for (let customValue of groupToContent[slotName]) {
                    if (customValue.match(/{[\s\S]+?}/g)) {
                        // custom value has slots, should bubble up as sample utterance
                        utteranceStructures.push(customValue);
                    } else {
                        customValues.push(customValue);
                    }
                }

                if (customValues && customValues.length > 0 && !BUILT_IN_INTENT_UTTERANCES[locale][slotName]) {
                    customIntentBuilder
                        .withSampleUtterance(`{${slotName}}`);
                    
                    if (!alreadyUsedSlotName[slotName]) {
                        customIntentBuilder
                        .withSlot((slotBuilder: ISlotBuilder) => slotBuilder
                            .withSlotName(slotName)
                            .withCustomSlotType(slotName));

                        interactionModelBuilder.withCustomSlotType((customSlotTypeBuilder: ICustomSlotTypeBuilder) => {
                            customSlotTypeBuilder.withCustomSlotTypeName(slotName)
                                .withCustomValues(() => customValues)
                            });

                        alreadyUsedSlotName[slotName] = true;
                    }
                }

                for (let utteranceStructure of utteranceStructures) {
                    let utteranceFinal: string = utteranceStructure;
                    
                    let slotRegex: RegExp = /{([\s\S]+?)(?: as ([\s\S]+?))?}/g;
                    let slotMatch: any = slotRegex.exec(utteranceStructure);
                    while (slotMatch != null) {
                        let slotType: string = slotMatch[1].trim();

                        let slotName: string = slotType;
                        if (slotMatch[2] && slotMatch[2].length > 0) {
                            slotName = slotMatch[2].trim();

                            utteranceFinal = utteranceFinal.replace(slotMatch[0], `{${slotName}}`);
                        }

                        if (!alreadyUsedSlotName[slotName]) {
                            customIntentBuilder.withSlot((slotBuilder: ISlotBuilder) => slotBuilder
                                .withSlotName(slotName)
                                .withCustomSlotType(slotType));

                            if (!slotType.startsWith("AMAZON.")) {
                                if (!importer.parameters.customSlots || !importer.parameters.customSlots[slotType]) {
                                    throw new Error(`[Error] Voice Model Generation: Could not find the values for custom slot type=${slotType}`);
                                }

                                if (!alreadyCreatedSlotType[slotType]) {
                                    interactionModelBuilder.withCustomSlotType((customSlotTypeBuilder: ICustomSlotTypeBuilder) => {
                                        customSlotTypeBuilder
                                            .withCustomSlotTypeName(slotType)
                                            .withCustomValues(() => importer.parameters.customSlots[slotType])
                                        });

                                        alreadyCreatedSlotType[slotType] = true;
                                }
                                
                            }

                            alreadyUsedSlotName[slotName] = true;
                        }

                        
                        slotMatch = slotRegex.exec(utteranceStructure);
                    }

                    customIntentBuilder.withSampleUtterance(utteranceFinal);

                }
            }
        }
    );

    for (let slotName in groupToContent) {
        if (BUILT_IN_INTENT_UTTERANCES[locale][slotName]) {
            interactionModelBuilder
                .withIntent((x: IIntentBuilder) => x
                    .withIntentName(slotName)
                    .withSampleUtterances(() => groupToContent[slotName]));
        }
    }

    let interactionModel: any = interactionModelBuilder.build();

    interactionModel.languageModel.invocationName = invocationName;
    
    return interactionModel;
}