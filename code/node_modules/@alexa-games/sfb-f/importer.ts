/**
 * abc-importer
 * 
 * Imports and exports between various branched content formats and the Alexa Branching Content (ABC) format.
 */
import * as fs from "fs";

import { DefaultFormatImportPlugin } from './importPlugins/DefaultFormatImportPlugin';

import { AlexaABCVerifier } from "./verificationHandlers/alexa-abc-verifier";
import { ABCImportPlugin, ABCExporter, StoryMetadata, SceneDirectionType, ImportResult, ImportErrorLine, ImportError } from "./aceEntities/interfaces";
import { ModelBaker } from "./bakeUtilities/VoiceModelBaker";
import { DriverExtension, ImporterExtension, InstructionExtension,
	isDriverExtension, isImporterExtension, isInstructionExtension } from "./extensions/ACEExtension";
import { StoryMetadataHelper } from "./importPlugins/storyMetadataHelper";
import { SourceContentHelper } from "./importPlugins/sourceContentHelper";

export interface ContentItem {
    id?: string,
    text: string
}

export class ACEImporter
{	
	importHandlersByType : {[key: string] : ABCImportPlugin} = {};
	
	exportHandlersByType : {[key: string] : ABCExporter} = {};

	importExtensions: (DriverExtension|ImporterExtension|InstructionExtension)[] = [];

	verifier : AlexaABCVerifier = new AlexaABCVerifier();

	// Constructor
	public constructor(customImporters?: ABCImportPlugin[], customerExporters?: {[key: string]: ABCExporter}, extensions?: (DriverExtension|ImporterExtension|InstructionExtension)[]) {
		let importPlugins: ABCImportPlugin[] = [
			new DefaultFormatImportPlugin()
		];
		
		if (customImporters) {
			importPlugins = importPlugins.concat(customImporters);
		}

		for (let importPlug of importPlugins) {
			this.importHandlersByType[importPlug.pluginName] = importPlug;
		}

		if (customerExporters) {
			Object.assign(this.exportHandlersByType, customerExporters);
		}

		if(extensions) {
			this.importExtensions = extensions;
		}
	}
	
	public async importABCStory(format : string, filename : string, storyTitle: string, storyID: string, autoIntentGrouping?: boolean, param: {[key: string]: any} = {}): Promise<StoryMetadata> {
		let contents: ContentItem[] = [];

		if (param.content) {
			contents.push({
				id: "default",
				text: param.content
			});
		} else if (param.contents) {
			contents = param.contents;
		} else {
			contents.push({
				id: filename,
				text: fs.readFileSync(filename, { encoding: 'utf8' })
			});
		}
		

		for (let extension of this.importExtensions) {
			if (isImporterExtension(extension)) {
				const sourceHelper = new SourceContentHelper(contents);
				await extension.extendSourceContent(sourceHelper);
				param.contents = sourceHelper.getAllSourceContents();
			}
		}

		let importHandler : ABCImportPlugin = this.importHandlersByType[format];

		const contentVersion: number = param.version;
		const optimalVersion = importHandler.getVersion();
		if (optimalVersion < contentVersion) {
			throw new Error(`Unsupported Language Version: Importer expected content version ${optimalVersion}, but detected version ${contentVersion}.`);
		}

		let thisObj = this;
		try {
			const importResult: ImportResult = await importHandler.importData(contents, param);
			const importedScenes = importResult.importedScenes;
			const importErrors = importResult.errors || [];

			let jsonObjOutput: StoryMetadata = {
				pluginName: importHandler.pluginName,
				scenes: importedScenes,
				storyID: storyID,
				storyTitle: storyTitle
			}

			for (let extension of this.importExtensions) {
				try {
					if (isImporterExtension(extension)) {
						const metadataHelper = new StoryMetadataHelper(jsonObjOutput);
						await extension.extendImportedContent(metadataHelper);
						jsonObjOutput = await metadataHelper.getStoryMetadata();
					}
				} catch (err) {
					const extensionError: ImportErrorLine = {
						lineNumber: 0,						
						errorMessage: err,
						errorName: `Import Extension Error on ${extension.constructor.name}`
					};

					importErrors.push(extensionError);
				}
			}
			
			if (!param.ignoreSyntaxError) {
				const finalError = await thisObj.verifier.verify(jsonObjOutput);
				finalError.forEach((errorItem) => {
					importErrors.push(errorItem);
				});
			}

			try {
				let voiceModel: any = await ModelBaker.bake(!!autoIntentGrouping, jsonObjOutput, importHandler, param.locale);
				if (autoIntentGrouping) {
					jsonObjOutput.alexaVoiceModel = voiceModel;	
				} else {
					let allUtterances: any = {};

					for (let scene of jsonObjOutput.scenes) {
						for (let content of scene.contents) {
							if (content.sceneDirections) {
								for (let direction of content.sceneDirections) {
									if (direction.directionType == SceneDirectionType.CHOICE) {
										allUtterances[direction.parameters.utterances] = 1;
									}
								}
							}
						}
					}

					jsonObjOutput.alexaVoiceModel = Object.keys(allUtterances);	
				}
			} catch(err) {
				importErrors.push({
					errorName: "VoiceModelBuildError",
					lineNumber: 0,
					errorMessage: err
				});
			}

			if (importErrors && importErrors.length > 0) {
				throw (<ImportError> {
					errorItems: importErrors,
					importedData: jsonObjOutput
				});
			} else {
				return jsonObjOutput;
			}
			
		} catch(err) {
			throw err;
		}
	}

	public exportTo(format : string, filename : string, outputFilename : string) {

		let fileData = fs.readFileSync(filename, { encoding: 'utf8' });

		let jsonInputObj = JSON.parse(fileData);

		let exportHandler : ABCExporter = this.exportHandlersByType[format];

		console.log(this.exportHandlersByType);

		exportHandler.exportData(jsonInputObj, function(outputData : {}) {

			console.log("Output Data:");
			console.log(outputData);
		
			fs.writeFileSync(outputFilename, outputData);
		});
	}
}
