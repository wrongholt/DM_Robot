import { StoryMetadata, UserInput } from "../aceEntities/interfaces";

//import assert = require('assert');
import { strict as assert } from 'assert';
import { StoryStateHelper } from "..";
import { ACEDriver } from "../driver";
import { ImporterExtension, InstructionExtension, DriverExtension } from './../extensions/ACEExtension';

type ExtensionType = ImporterExtension|DriverExtension|InstructionExtension;
export class ACEContentTester {
    private story: StoryMetadata;

    private state: any;

    private extensions: ExtensionType[];
    private driver: ACEDriver;

    constructor(storyData: StoryMetadata, extensions: ExtensionType[]) {
        this.story = storyData;
        this.state = {};
        this.extensions = extensions;
        this.driver = new ACEDriver(this.story, [], this.extensions);
    }

    /**
     * Resets the state of the test, and prepare for a new test run.
     */
    public resetTest() {
        this.state = {};
        this.driver = new ACEDriver(this.story, [], this.extensions);
    }

    /**
     * Cleans out the current run state.
     */
    public givenCleanState() {
        this.state = {};
    }

    public givenAttribute(attributeName: string, value: any): void {
        this.state[attributeName] = value;
    }

    public givenAttributes(attributes: { [key: string]: any }) {
        this.state = Object.assign(this.state, attributes);
    }

    /**
     * Sets the test, so that the current scene is as defined by sceneID
     * @param sceneID scene ID the test should move to.
     */
    public givenCurrentScene(sceneID: string): void {
        StoryStateHelper.setCurrentSceneID(this.state, sceneID);
    }

    /**
     * Run the story for given user input.
     * @param userInput instance of UserInput class of SFB module
     */
    public async givenUserInput(userInput: UserInput): Promise<void> {
        this.driver = new ACEDriver(this.story, [], this.extensions);

        await this.driver.resumeStory(userInput, this.state);
        this.state = this.driver.getCurrentStoryState();
    }

    /**
     * Invoke system level pause by signaling for pause event.
     */
    public async givenPauseInvoked(): Promise<void> {
        this.driver = new ACEDriver(this.story, [], this.extensions);

        await this.driver.pauseStory({
            intent: "AMAZON.PauseIntent"
        },this.state);
        this.state = this.driver.getCurrentStoryState();
    }

    /**
     * Invoke system level resume by signlaing for resume event.
     */
    public async givenResumeInvoked(): Promise<void> {
        this.driver = new ACEDriver(this.story, [], this.extensions);

        await this.driver.resumeStory({
            intent: "LaunchRequest",
            value: "LaunchRequest"
        }, this.state);

        this.state = this.driver.getCurrentStoryState();
    }

    /**
     * Invoke system level start by signaling for start/launch event.
     */
    public async givenStartInvoked(): Promise<void> {
        this.driver = new ACEDriver(this.story, [], this.extensions);
        await this.givenResumeInvoked();
    }

    public assertAttributeDefined(attributeName: string): void {
        assert.equal(this.state[attributeName] == undefined, false, `Attribute Assertion Failed`);
    }

    public assertAttributeUndefined(attributeName: string): void {
        assert.equal(this.state[attributeName] == undefined, true, `Attribute Assertion Failed`);
    }

    public assertAttributeEquals(attributeName: string, expected: any): void {
        assert.equal(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }

    public assertAttributeNotEquals(attributeName: string, expected: any): void {
        assert.notEqual(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }

    public assertSceneID(sceneID: string, msg: string = ""): void {
        let actualScene: string | null = StoryStateHelper.getCurrentSceneID(this.state);
        assert.equal(actualScene == null ? null : actualScene.trim().toLocaleLowerCase(), sceneID.trim().toLowerCase(), `Scene ID Assertion Failed: ${msg}`);
    }

    public async assertSpeech(expected: string) {
        let actual: string = await this.driver.getSpeechSSMLText();
        assert.equal(actual.trim(), expected.trim(), `Speech Assertion Failed`);
    }

    public async assertSpeechOneOf(expected: string[]) {
        let actual: string = await this.driver.getSpeechSSMLText();
        assert(expected.includes(actual.trim()), `Speech Assertion Failed.`);
    }

    public async assertReprompt(expected: string) {
        let actual: string = await this.driver.getRepromptSSMLText();
        assert.equal(actual.trim(), expected.trim(), `Reprompt Assertion Failed`);
    }

    public async getSpeech() {
        return await this.driver.getSpeechSSMLText();
    }

    public async getReprompt() {
        return await this.driver.getRepromptSSMLText();
    }

    public async getAttributeValue(attributeName: string) {
        return this.state[attributeName];
    }

    public async assertAttributeExists(attributeName: string) {
        let actual: string = this.state[attributeName];
        assert(actual != undefined, attributeName + ' undefined');
    }

    public async assertTime(timeAttribute: string, before: number, after: number) {
        let time: number = +this.state[timeAttribute];
        assert(time >= before && time <= after, 'Invalid time');
    }
}
