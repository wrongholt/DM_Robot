"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//import assert = require('assert');
const assert_1 = require("assert");
const __1 = require("..");
const driver_1 = require("../driver");
class ACEContentTester {
    constructor(storyData, extensions) {
        this.story = storyData;
        this.state = {};
        this.extensions = extensions;
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
    }
    /**
     * Resets the state of the test, and prepare for a new test run.
     */
    resetTest() {
        this.state = {};
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
    }
    /**
     * Cleans out the current run state.
     */
    givenCleanState() {
        this.state = {};
    }
    givenAttribute(attributeName, value) {
        this.state[attributeName] = value;
    }
    givenAttributes(attributes) {
        this.state = Object.assign(this.state, attributes);
    }
    /**
     * Sets the test, so that the current scene is as defined by sceneID
     * @param sceneID scene ID the test should move to.
     */
    givenCurrentScene(sceneID) {
        __1.StoryStateHelper.setCurrentSceneID(this.state, sceneID);
    }
    /**
     * Run the story for given user input.
     * @param userInput instance of UserInput class of SFB module
     */
    async givenUserInput(userInput) {
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
        await this.driver.resumeStory(userInput, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level pause by signaling for pause event.
     */
    async givenPauseInvoked() {
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
        await this.driver.pauseStory({
            intent: "AMAZON.PauseIntent"
        }, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level resume by signlaing for resume event.
     */
    async givenResumeInvoked() {
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
        await this.driver.resumeStory({
            intent: "LaunchRequest",
            value: "LaunchRequest"
        }, this.state);
        this.state = this.driver.getCurrentStoryState();
    }
    /**
     * Invoke system level start by signaling for start/launch event.
     */
    async givenStartInvoked() {
        this.driver = new driver_1.ACEDriver(this.story, [], this.extensions);
        await this.givenResumeInvoked();
    }
    assertAttributeDefined(attributeName) {
        assert_1.strict.equal(this.state[attributeName] == undefined, false, `Attribute Assertion Failed`);
    }
    assertAttributeUndefined(attributeName) {
        assert_1.strict.equal(this.state[attributeName] == undefined, true, `Attribute Assertion Failed`);
    }
    assertAttributeEquals(attributeName, expected) {
        assert_1.strict.equal(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }
    assertAttributeNotEquals(attributeName, expected) {
        assert_1.strict.notEqual(this.state[attributeName], expected, `Attribute Assertion Failed`);
    }
    assertSceneID(sceneID, msg = "") {
        let actualScene = __1.StoryStateHelper.getCurrentSceneID(this.state);
        assert_1.strict.equal(actualScene == null ? null : actualScene.trim().toLocaleLowerCase(), sceneID.trim().toLowerCase(), `Scene ID Assertion Failed: ${msg}`);
    }
    async assertSpeech(expected) {
        let actual = await this.driver.getSpeechSSMLText();
        assert_1.strict.equal(actual.trim(), expected.trim(), `Speech Assertion Failed`);
    }
    async assertSpeechOneOf(expected) {
        let actual = await this.driver.getSpeechSSMLText();
        assert_1.strict(expected.includes(actual.trim()), `Speech Assertion Failed.`);
    }
    async assertReprompt(expected) {
        let actual = await this.driver.getRepromptSSMLText();
        assert_1.strict.equal(actual.trim(), expected.trim(), `Reprompt Assertion Failed`);
    }
    async getSpeech() {
        return await this.driver.getSpeechSSMLText();
    }
    async getReprompt() {
        return await this.driver.getRepromptSSMLText();
    }
    async getAttributeValue(attributeName) {
        return this.state[attributeName];
    }
    async assertAttributeExists(attributeName) {
        let actual = this.state[attributeName];
        assert_1.strict(actual != undefined, attributeName + ' undefined');
    }
    async assertTime(timeAttribute, before, after) {
        let time = +this.state[timeAttribute];
        assert_1.strict(time >= before && time <= after, 'Invalid time');
    }
}
exports.ACEContentTester = ACEContentTester;
//# sourceMappingURL=ACEContentTester.js.map