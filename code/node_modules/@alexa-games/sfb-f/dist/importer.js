"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * abc-importer
 *
 * Imports and exports between various branched content formats and the Alexa Branching Content (ABC) format.
 */
const fs = __importStar(require("fs"));
const DefaultFormatImportPlugin_1 = require("./importPlugins/DefaultFormatImportPlugin");
const alexa_abc_verifier_1 = require("./verificationHandlers/alexa-abc-verifier");
const interfaces_1 = require("./aceEntities/interfaces");
const VoiceModelBaker_1 = require("./bakeUtilities/VoiceModelBaker");
const ACEExtension_1 = require("./extensions/ACEExtension");
const storyMetadataHelper_1 = require("./importPlugins/storyMetadataHelper");
const sourceContentHelper_1 = require("./importPlugins/sourceContentHelper");
class ACEImporter {
    // Constructor
    constructor(customImporters, customerExporters, extensions) {
        this.importHandlersByType = {};
        this.exportHandlersByType = {};
        this.importExtensions = [];
        this.verifier = new alexa_abc_verifier_1.AlexaABCVerifier();
        let importPlugins = [
            new DefaultFormatImportPlugin_1.DefaultFormatImportPlugin()
        ];
        if (customImporters) {
            importPlugins = importPlugins.concat(customImporters);
        }
        for (let importPlug of importPlugins) {
            this.importHandlersByType[importPlug.pluginName] = importPlug;
        }
        if (customerExporters) {
            Object.assign(this.exportHandlersByType, customerExporters);
        }
        if (extensions) {
            this.importExtensions = extensions;
        }
    }
    async importABCStory(format, filename, storyTitle, storyID, autoIntentGrouping, param = {}) {
        let contents = [];
        if (param.content) {
            contents.push({
                id: "default",
                text: param.content
            });
        }
        else if (param.contents) {
            contents = param.contents;
        }
        else {
            contents.push({
                id: filename,
                text: fs.readFileSync(filename, { encoding: 'utf8' })
            });
        }
        for (let extension of this.importExtensions) {
            if (ACEExtension_1.isImporterExtension(extension)) {
                const sourceHelper = new sourceContentHelper_1.SourceContentHelper(contents);
                await extension.extendSourceContent(sourceHelper);
                param.contents = sourceHelper.getAllSourceContents();
            }
        }
        let importHandler = this.importHandlersByType[format];
        const contentVersion = param.version;
        const optimalVersion = importHandler.getVersion();
        if (optimalVersion < contentVersion) {
            throw new Error(`Unsupported Language Version: Importer expected content version ${optimalVersion}, but detected version ${contentVersion}.`);
        }
        let thisObj = this;
        try {
            const importResult = await importHandler.importData(contents, param);
            const importedScenes = importResult.importedScenes;
            const importErrors = importResult.errors || [];
            let jsonObjOutput = {
                pluginName: importHandler.pluginName,
                scenes: importedScenes,
                storyID: storyID,
                storyTitle: storyTitle
            };
            for (let extension of this.importExtensions) {
                try {
                    if (ACEExtension_1.isImporterExtension(extension)) {
                        const metadataHelper = new storyMetadataHelper_1.StoryMetadataHelper(jsonObjOutput);
                        await extension.extendImportedContent(metadataHelper);
                        jsonObjOutput = await metadataHelper.getStoryMetadata();
                    }
                }
                catch (err) {
                    const extensionError = {
                        lineNumber: 0,
                        errorMessage: err,
                        errorName: `Import Extension Error on ${extension.constructor.name}`
                    };
                    importErrors.push(extensionError);
                }
            }
            if (!param.ignoreSyntaxError) {
                const finalError = await thisObj.verifier.verify(jsonObjOutput);
                finalError.forEach((errorItem) => {
                    importErrors.push(errorItem);
                });
            }
            try {
                let voiceModel = await VoiceModelBaker_1.ModelBaker.bake(!!autoIntentGrouping, jsonObjOutput, importHandler, param.locale);
                if (autoIntentGrouping) {
                    jsonObjOutput.alexaVoiceModel = voiceModel;
                }
                else {
                    let allUtterances = {};
                    for (let scene of jsonObjOutput.scenes) {
                        for (let content of scene.contents) {
                            if (content.sceneDirections) {
                                for (let direction of content.sceneDirections) {
                                    if (direction.directionType == interfaces_1.SceneDirectionType.CHOICE) {
                                        allUtterances[direction.parameters.utterances] = 1;
                                    }
                                }
                            }
                        }
                    }
                    jsonObjOutput.alexaVoiceModel = Object.keys(allUtterances);
                }
            }
            catch (err) {
                importErrors.push({
                    errorName: "VoiceModelBuildError",
                    lineNumber: 0,
                    errorMessage: err
                });
            }
            if (importErrors && importErrors.length > 0) {
                throw {
                    errorItems: importErrors,
                    importedData: jsonObjOutput
                };
            }
            else {
                return jsonObjOutput;
            }
        }
        catch (err) {
            throw err;
        }
    }
    exportTo(format, filename, outputFilename) {
        let fileData = fs.readFileSync(filename, { encoding: 'utf8' });
        let jsonInputObj = JSON.parse(fileData);
        let exportHandler = this.exportHandlersByType[format];
        console.log(this.exportHandlersByType);
        exportHandler.exportData(jsonInputObj, function (outputData) {
            console.log("Output Data:");
            console.log(outputData);
            fs.writeFileSync(outputFilename, outputData);
        });
    }
}
exports.ACEImporter = ACEImporter;
//# sourceMappingURL=importer.js.map