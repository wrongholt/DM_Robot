"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interfaces_1 = require("../aceEntities/interfaces");
const sfb_util_1 = require("@alexa-games/sfb-util");
const BuiltInIntents_1 = require("./BuiltInIntents");
class ModelBaker {
    static async bake(autoIntentGrouping, story, importer, _locale = 'en') {
        let locale = _locale;
        if (!BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale] && BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale.split("-")[0]]) {
            locale = locale.split("-")[0];
        }
        let choiceGrouping = {};
        for (let intentName in BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale]) {
            for (let utterance of BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale][intentName]) {
                choiceGrouping[utterance.toLowerCase()] = intentName;
            }
        }
        let slotTracker = {};
        if (autoIntentGrouping) {
            let slotCount = 0;
            for (let scene of story.scenes) {
                for (let content of scene.contents) {
                    if (content.sceneDirections) {
                        let directionQueue = JSON.parse(JSON.stringify(content.sceneDirections));
                        let choiceDirections = [];
                        while (directionQueue.length > 0) {
                            let verifyingDirection = directionQueue.splice(0, 1)[0];
                            if (verifyingDirection.directionType === interfaces_1.SceneDirectionType.SLOT) {
                                let name = verifyingDirection.parameters.variableName;
                                let type = verifyingDirection.parameters.variableType;
                                slotTracker[name] = type;
                            }
                            else if (verifyingDirection.directionType === interfaces_1.SceneDirectionType.CHOICE) {
                                verifyingDirection.parameters.utterances = JSON.parse(JSON.stringify(verifyingDirection.parameters.utterances).replace(/{([\s\S]+?)(?: as ([\s\S]+?))?}/g, function (match, p1, p2) {
                                    if (p1 && !p2 && slotTracker[p1]) {
                                        return `{${slotTracker[p1]} as ${p1}}`;
                                    }
                                    return match;
                                }));
                                choiceDirections.push(verifyingDirection);
                            }
                            else if (verifyingDirection.directionType === interfaces_1.SceneDirectionType.CONDITION) {
                                directionQueue = directionQueue.concat(verifyingDirection.parameters.directions);
                            }
                        }
                        convertDecisions2Groups.call(this, choiceGrouping, choiceDirections, function (choice) {
                            return choice.parameters.utterances;
                        }, locale, slotCount);
                    }
                }
            }
        }
        for (let scene of story.scenes) {
            for (let bodyContent of scene.contents) {
                if (bodyContent.sceneDirections) {
                    for (let directionIndex in bodyContent.sceneDirections) {
                        if (bodyContent.sceneDirections[directionIndex].parameters.utteranceGrouped) {
                            delete bodyContent.sceneDirections[directionIndex].parameters.utteranceGrouped;
                        }
                    }
                }
            }
        }
        return buildVoiceModelWithGrouping(choiceGrouping, "", importer, locale);
    }
}
exports.ModelBaker = ModelBaker;
const SLOT_VERSION_BASE = 26;
const A_CHAR_CODE = 'a'.charCodeAt(0);
function numberToAlphabetCounting(i) {
    const base26Count = i.toString(SLOT_VERSION_BASE);
    const alphaBaseCount = base26Count.replace(/./g, (match) => {
        if (isNaN(parseInt(match, 10))) {
            return String.fromCharCode(match.charCodeAt(0) + 10);
        }
        else {
            return String.fromCharCode(A_CHAR_CODE + parseInt(match, 10));
        }
    });
    return alphaBaseCount;
}
exports.numberToAlphabetCounting = numberToAlphabetCounting;
function convertDecisions2Groups(grouping, choices, parsingFunction, locale, slotCount) {
    for (let intentName in BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale]) {
        for (let utterance of BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale][intentName]) {
            grouping[utterance] = intentName;
        }
    }
    let crossReference = {};
    let decisionIndex = 0;
    for (let choice of choices) {
        let words = parsingFunction(choice);
        let groupNameToApply = undefined;
        // find already existing group
        for (let word of words) {
            if (word != "$auto" && word != "*") {
                let groupName = grouping[word.trim()];
                if ((groupName && groupName.startsWith("AMAZON.")) || BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale][word.trim()]) {
                    continue;
                }
                else if (groupName) {
                    if (crossReference[groupName] != undefined && crossReference[groupName] < decisionIndex) {
                        grouping[word.trim()] = `${numberToAlphabetCounting(slotCount)}Slot`;
                        slotCount++;
                    }
                    else {
                        groupNameToApply = groupName;
                        crossReference[groupNameToApply] = decisionIndex;
                    }
                }
                else if (!groupNameToApply) {
                    groupNameToApply = `${numberToAlphabetCounting(slotCount)}Slot`;
                    slotCount++;
                    crossReference[groupNameToApply] = decisionIndex;
                }
            }
        }
        for (let word of words) {
            if (word != "$auto") {
                if (!grouping[word.trim()] && groupNameToApply) {
                    grouping[word.trim()] = groupNameToApply;
                }
            }
        }
        decisionIndex++;
    }
}
function buildVoiceModelWithGrouping(grouping, invocationName, importer, locale) {
    let groupToContent = {};
    for (let key in grouping) {
        let groupName = grouping[key];
        let wordValue = key.trim();
        if (!groupToContent[groupName]) {
            groupToContent[groupName] = [];
        }
        groupToContent[groupName].push(wordValue);
    }
    let interactionModelBuilder = new sfb_util_1.InteractionModelBuilder();
    interactionModelBuilder.withIntent((customIntentBuilder) => {
        customIntentBuilder.withIntentName("FlexibleAnswerIntent");
        let alreadyUsedSlotName = {};
        let alreadyCreatedSlotType = {};
        for (let slotName in groupToContent) {
            let customValues = [];
            let utteranceStructures = [];
            for (let customValue of groupToContent[slotName]) {
                if (customValue.match(/{[\s\S]+?}/g)) {
                    // custom value has slots, should bubble up as sample utterance
                    utteranceStructures.push(customValue);
                }
                else {
                    customValues.push(customValue);
                }
            }
            if (customValues && customValues.length > 0 && !BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale][slotName]) {
                customIntentBuilder
                    .withSampleUtterance(`{${slotName}}`);
                if (!alreadyUsedSlotName[slotName]) {
                    customIntentBuilder
                        .withSlot((slotBuilder) => slotBuilder
                        .withSlotName(slotName)
                        .withCustomSlotType(slotName));
                    interactionModelBuilder.withCustomSlotType((customSlotTypeBuilder) => {
                        customSlotTypeBuilder.withCustomSlotTypeName(slotName)
                            .withCustomValues(() => customValues);
                    });
                    alreadyUsedSlotName[slotName] = true;
                }
            }
            for (let utteranceStructure of utteranceStructures) {
                let utteranceFinal = utteranceStructure;
                let slotRegex = /{([\s\S]+?)(?: as ([\s\S]+?))?}/g;
                let slotMatch = slotRegex.exec(utteranceStructure);
                while (slotMatch != null) {
                    let slotType = slotMatch[1].trim();
                    let slotName = slotType;
                    if (slotMatch[2] && slotMatch[2].length > 0) {
                        slotName = slotMatch[2].trim();
                        utteranceFinal = utteranceFinal.replace(slotMatch[0], `{${slotName}}`);
                    }
                    if (!alreadyUsedSlotName[slotName]) {
                        customIntentBuilder.withSlot((slotBuilder) => slotBuilder
                            .withSlotName(slotName)
                            .withCustomSlotType(slotType));
                        if (!slotType.startsWith("AMAZON.")) {
                            if (!importer.parameters.customSlots || !importer.parameters.customSlots[slotType]) {
                                throw new Error(`[Error] Voice Model Generation: Could not find the values for custom slot type=${slotType}`);
                            }
                            if (!alreadyCreatedSlotType[slotType]) {
                                interactionModelBuilder.withCustomSlotType((customSlotTypeBuilder) => {
                                    customSlotTypeBuilder
                                        .withCustomSlotTypeName(slotType)
                                        .withCustomValues(() => importer.parameters.customSlots[slotType]);
                                });
                                alreadyCreatedSlotType[slotType] = true;
                            }
                        }
                        alreadyUsedSlotName[slotName] = true;
                    }
                    slotMatch = slotRegex.exec(utteranceStructure);
                }
                customIntentBuilder.withSampleUtterance(utteranceFinal);
            }
        }
    });
    for (let slotName in groupToContent) {
        if (BuiltInIntents_1.BUILT_IN_INTENT_UTTERANCES[locale][slotName]) {
            interactionModelBuilder
                .withIntent((x) => x
                .withIntentName(slotName)
                .withSampleUtterances(() => groupToContent[slotName]));
        }
    }
    let interactionModel = interactionModelBuilder.build();
    interactionModel.languageModel.invocationName = invocationName;
    return interactionModel;
}
//# sourceMappingURL=VoiceModelBaker.js.map