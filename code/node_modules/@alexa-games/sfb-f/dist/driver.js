"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interfaces_1 = require("./aceEntities/interfaces");
const StoryAccessor_1 = require("./storyEntities/StoryAccessor");
const DefaultFormatImportPlugin_1 = require("./importPlugins/DefaultFormatImportPlugin");
const ACEExtension_1 = require("./extensions/ACEExtension");
const StoryStateHelper_1 = require("./StoryStateHelper");
const crypto_1 = require("crypto");
const PlayStage_1 = require("./storyEntities/PlayStage");
const userInputHelper_1 = require("./importPlugins/userInputHelper");
const TOTAL_SCENES_PROCESS_SAFEGUARD = 1000;
const isWin = (process.platform === "win32");
const AlexaPolly = require('@alexa-games/sfb-polly');
let POLLY_ENABLED = true;
let pollyConfig = undefined;
class ACEDriver {
    constructor(storyMetadata, customImportPlugins, extensions, pollyConfiguration, locale = 'en-US') {
        this.isPollyAsDefault = false;
        this.importHandlersByType = {};
        this.customExtensions = [];
        this.resultOptions = [];
        this.playQueue = [];
        this.unhandledChoiceFlag = false;
        this.isPausing = false;
        this.isRepeating = false;
        this.voiceName = "Brian";
        this.pitch = "";
        this.rate = "";
        this.volume = 1;
        this.historySize = 10;
        this.locale = locale;
        POLLY_ENABLED = pollyConfiguration ? pollyConfiguration.enabled : false; // Default to polly config off
        pollyConfig = pollyConfiguration || {};
        if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
            if (pollyConfiguration) {
                AlexaPolly.configureOptions(pollyConfiguration);
            }
            else {
                if (isWin) {
                    AlexaPolly.configureOptions({ bucketName: "cyoa-public", combineAudioTags: true, dontUseCache: false, FFMPEGLocation: "..\\ffmpeg.exe", windowsOS: true, workingDir: "c:\\Tmp", ffmpegBinName: "ffmpeg.exe" });
                }
                else {
                    AlexaPolly.configureOptions({ bucketName: "cyoa-public", combineAudioTags: true, dontUseCache: false });
                }
            }
        }
        this.storyAccessor = new StoryAccessor_1.StoryAccessor(storyMetadata);
        this.storyState = {};
        this.stage = new PlayStage_1.PlayStage();
        let importPlugins = [
            new DefaultFormatImportPlugin_1.DefaultFormatImportPlugin()
        ];
        if (customImportPlugins) {
            importPlugins = importPlugins.concat(customImportPlugins);
        }
        for (let importPlug of importPlugins) {
            this.importHandlersByType[importPlug.pluginName] = importPlug;
        }
        if (extensions) {
            this.customExtensions = this.customExtensions.concat(extensions);
        }
    }
    /**
     * invoke before calling resumeStory if the story history and progress needs to be reset by running the start sequence.
     * onStart implementation of all registered extensions are run.
     *
     * @param startingStoryState
     */
    async resetStory(startingStoryState) {
        this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));
        StoryStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, interfaces_1.BuiltInScenes.StartScene);
        StoryStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
        StoryStateHelper_1.StoryStateHelper.resetChoiceHistory(this.storyState);
        return;
    }
    /**
     * Resume the story.
     * If story has been paused, run the resume cycle by playing the 'Resume' scene first.
     * Otherwise, Run normally from the bookmarked scene ID.
     *
     * @param userInput
     * @param startingStoryState
     */
    async resumeStory(_userInput, startingStoryState) {
        try {
            this.storyState = JSON.parse(JSON.stringify(startingStoryState || this.storyState));
            // create instructions memory
            if (!this.storyState.system_instruction_mem) {
                this.storyState.system_instruction_mem = {};
            }
            if (StoryStateHelper_1.StoryStateHelper.isEndingReached(this.storyState)) {
                delete this.storyState.system_prevRecap;
                delete this.storyState.system_prevSpeech;
                StoryStateHelper_1.StoryStateHelper.setEndingReached(this.storyState, false);
            }
            this.playQueue = [];
            this.unhandledChoiceFlag = false; // Reset to false
            this.isRepeating = false;
            // apply user input extension by DriverExtensions
            const inputHelper = new userInputHelper_1.UserInputHelper(_userInput);
            for (let extension of this.customExtensions) {
                if (!ACEExtension_1.isDriverExtension(extension)) {
                    continue;
                }
                await extension.pre({
                    driver: this,
                    storyState: this.storyState,
                    userInputHelper: inputHelper
                });
            }
            const userInput = inputHelper.getUserInput();
            if (!StoryStateHelper_1.StoryStateHelper.isStoryPaused(this.storyState)) {
                await this.processChoice.call(this, userInput);
            }
            if (!this.isRepeating) {
                if (ACEDriver.debug)
                    console.log("[DEBUG] Play queue length: " + this.playQueue.length);
                if (this.playQueue.length === 0) {
                    let bookmarkedSceneID = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                    if (ACEDriver.debug)
                        console.log("[DEBUG] Current bookmark: " + bookmarkedSceneID);
                    if (bookmarkedSceneID == null) {
                        if (ACEDriver.debug)
                            console.log("[DEBUG] Enqueue start scene");
                        this.playQueue.push({
                            sceneID: interfaces_1.BuiltInScenes.StartScene,
                            property: "narration"
                        });
                    }
                    else {
                        let resumeExists = false;
                        try {
                            let scene = await this.getSceneByID(interfaces_1.BuiltInScenes.ResumeScene);
                            if (scene) {
                                resumeExists = true;
                            }
                        }
                        catch (err) {
                            resumeExists = false;
                        }
                        if (StoryStateHelper_1.StoryStateHelper.isStoryPaused(this.storyState) && resumeExists) {
                            if (ACEDriver.debug)
                                console.log("[DEBUG] Enqueue resume scene, and clear choices.");
                            StoryStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
                            if (StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) !== interfaces_1.BuiltInScenes.PauseScene) {
                                this.storyState.resume = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                            }
                            this.playQueue.push({
                                sceneID: interfaces_1.BuiltInScenes.ResumeScene,
                                property: "narration"
                            });
                        }
                        else {
                            if (ACEDriver.debug)
                                console.log("[DEBUG] Enqueue saved scene: " + bookmarkedSceneID);
                            this.playQueue.push({
                                sceneID: bookmarkedSceneID,
                                property: "narration"
                            });
                        }
                        // Also set a flag to indicate that we hit an unhandled choice so the caller can do something different if they want to
                        this.unhandledChoiceFlag = true;
                    }
                }
                StoryStateHelper_1.StoryStateHelper.setStoryPaused(this.storyState, false);
                if (!this.storyState.system_originStack) {
                    this.storyState.system_originStack = [];
                }
                this.storyState.system_originStack.push(this.playQueue[0]);
                if (this.storyState.system_originStack.length > this.historySize) {
                    // too large, remove first item
                    this.storyState.system_originStack.splice(0, 1);
                }
                let totalScenesProcessedCount = 0;
                while (this.playQueue.length > 0 && !this.isPausing) {
                    let dequeuedSceneID = this.playQueue.splice(0, 1)[0];
                    if (ACEDriver.debug)
                        console.log("[DEBUG] Setting the current scene to: " + dequeuedSceneID);
                    this.stage.logVisitedScene(dequeuedSceneID.sceneID);
                    StoryStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, dequeuedSceneID.sceneID);
                    let preProcessState = JSON.stringify(this.storyState);
                    await this.processScene.call(this, undefined, dequeuedSceneID.property);
                    if (ACEDriver.testing) {
                        let beforeStructure = JSON.parse(preProcessState);
                        console.log("\n");
                        check("", beforeStructure, this.storyState);
                    }
                    totalScenesProcessedCount++;
                    if (totalScenesProcessedCount >= TOTAL_SCENES_PROCESS_SAFEGUARD) {
                        throw "[ACE Driver - Infinite Loop] Looped " + TOTAL_SCENES_PROCESS_SAFEGUARD + " times, last scene ID was: " + dequeuedSceneID.sceneID + ". Please fix your inifite loop.";
                    }
                }
                if (this.isPausing) {
                    this.isPausing = false;
                    await this.pauseStory(_userInput);
                }
            }
            this.storyState.system_prevSpeech = this.stage.getStageSpeechAudioSequence();
            this.storyState.system_prevReprompt = this.stage.getStageRepromptAudioSequence();
            this.storyState.system_prevRecap = this.stage.getStageRecapAudioSequence();
            // apply user input extension by DriverExtensions
            for (let extension of this.customExtensions) {
                if (!ACEExtension_1.isDriverExtension(extension)) {
                    continue;
                }
                await extension.post({
                    driver: this,
                    storyState: this.storyState,
                    userInputHelper: inputHelper
                });
            }
            return;
        }
        catch (err) {
            throw err;
        }
    }
    /**
     * Run the pause sequence by playing the 'Pause' scene.
     *
     * @param startingStoryState
     */
    async pauseStory(_userInput, startingStoryState) {
        this.storyState = Object.assign({}, startingStoryState || this.storyState);
        // create instructions memory
        if (!this.storyState.system_instruction_mem) {
            this.storyState.system_instruction_mem = {};
        }
        let savingSceneID = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
        if (savingSceneID == interfaces_1.BuiltInScenes.ResumeScene) {
            savingSceneID = this.storyState.resume;
        }
        StoryStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, interfaces_1.BuiltInScenes.PauseScene);
        let preProcessState = JSON.stringify(this.storyState);
        await this.processScene.call(this);
        if (ACEDriver.testing) {
            let beforeStructure = JSON.parse(preProcessState);
            console.log("\n");
            check("", beforeStructure, this.storyState);
        }
        // saving the previous scene for next resume.
        StoryStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, savingSceneID === null ? interfaces_1.BuiltInScenes.StartScene : savingSceneID);
        StoryStateHelper_1.StoryStateHelper.setStoryPaused(this.storyState, true);
        // apply user input extension by DriverExtensions
        const inputHelper = new userInputHelper_1.UserInputHelper(_userInput);
        for (let extension of this.customExtensions) {
            if (!ACEExtension_1.isDriverExtension(extension)) {
                continue;
            }
            await extension.post({
                driver: this,
                storyState: this.storyState,
                userInputHelper: inputHelper
            });
        }
        return;
    }
    /**
     * Undo a choice.
     */
    async undoLastChoice(storyState) {
        let choiceHistory = StoryStateHelper_1.StoryStateHelper.getChoiceHistory(storyState);
        if (choiceHistory && choiceHistory.length > 0) {
            let lastChoice = choiceHistory[choiceHistory.length - 1];
            for (let stateDiff of lastChoice.stateDiff) {
                if (stateDiff.beforeValue === undefined) {
                    delete storyState[stateDiff.itemName];
                }
                else {
                    storyState[stateDiff.itemName] = stateDiff.beforeValue;
                }
            }
            choiceHistory.splice(-1, 1); // pop 
        }
        StoryStateHelper_1.StoryStateHelper.setChoiceHistory(storyState, choiceHistory);
        return;
    }
    async enqueueNextSceneID(nextSceneID) {
        this.playQueue.push({
            sceneID: nextSceneID,
            property: "narration"
        });
    }
    /**
     * Configure the default polly narrator settings.
     * @param voiceName
     * @param pitch
     * @param rate
     * @param volume
     */
    configureDefaultPollyNarrator(voiceName, pitch, rate, volume) {
        this.voiceName = voiceName;
        this.pitch = pitch;
        this.rate = rate;
        this.volume = volume;
        AlexaPolly.registerVoiceName(voiceName, { name: voiceName, rate: rate, pitch: pitch });
    }
    /**
     * Turning on the 'default polly' causes all narration texts (including the ones not surrounded by the 'voice' tag) to be read in polly voice.
     * The polly voice setting for this can be configured by calling configureDefaultPollyNarrator().
     */
    turnOnDefaultPolly() {
        this.isPollyAsDefault = true;
    }
    /**
     * Turning off the 'default polly' causes all narration texts (texts NOT surrounded by the 'voice' tag) to be processed as non-polly voice.
     */
    turnOffDefaultPolly() {
        this.isPollyAsDefault = false;
    }
    buildAudioBuilder(audioBuilder) {
        return new Promise(async (resolve, reject) => {
            audioBuilder.buildAudioFile(function (outputUrl, err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(outputUrl);
            }, this);
        });
    }
    combineSSMLAudioTags(ssmlIn) {
        return new Promise(async (resolve, reject) => {
            console.log("combining: " + ssmlIn);
            AlexaPolly.combineAudioTags(ssmlIn, function (ssmlOut) {
                console.log("combined to : " + ssmlOut);
                resolve(ssmlOut);
            });
        });
    }
    async getSpeechSSMLText() {
        try {
            let { ssml } = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());
            return ssml;
        }
        catch (err) {
            throw err;
        }
    }
    async getSpeechSSMLAndPrettyText() {
        try {
            let { ssml, pretty } = await this.buildAudioScenes(this.stage.getStageSpeechAudioSequence());
            return { ssml, pretty };
        }
        catch (err) {
            throw err;
        }
    }
    async getRepromptSSMLText() {
        try {
            let { ssml } = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());
            return ssml;
        }
        catch (err) {
            throw err;
        }
    }
    async getRepromptSSMLAndPrettyText() {
        try {
            let { ssml, pretty } = await this.buildAudioScenes(this.stage.getStageRepromptAudioSequence());
            return { ssml, pretty };
        }
        catch (err) {
            throw err;
        }
    }
    async getVisuals() {
        return this.stage.getStageVisualOptions();
    }
    async buildAudioScenes(sceneAudioItemList) {
        try {
            let overallSSML = "";
            let prettySSML = "";
            for (let audioItem of sceneAudioItemList) {
                let foregroundSSML = "";
                for (let foregroundAudio of audioItem.foreground) {
                    // Build the foreground audio up into a single ssml tag
                    if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
                        if (foregroundAudio.type === interfaces_1.AlexaAudioType.AUDIO) {
                            // If values are defaults, then don't change the audio file at all and keep it at it's original quality
                            if (!POLLY_ENABLED || (foregroundAudio.delay == 0 && foregroundAudio.volume == 1.0)) {
                                foregroundSSML += `<audio src='${foregroundAudio.content}' />`;
                                prettySSML += `<audio src='${foregroundAudio.content}' />`;
                            }
                            else {
                                let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                                audioBuilder.addSFXSequence({ url: foregroundAudio.content, delayMs: foregroundAudio.delay, volume: foregroundAudio.volume });
                                let audioUrl = await this.buildAudioBuilder(audioBuilder);
                                foregroundSSML += `<audio src='${audioUrl}' />`;
                                prettySSML += `<audio src='${audioUrl}' />`;
                            }
                        }
                        else if (foregroundAudio.type === interfaces_1.AlexaAudioType.POLLY) {
                            if (foregroundAudio.options) {
                                if (!POLLY_ENABLED) {
                                    const hasProsodyMod = !!((foregroundAudio.options.pitch && foregroundAudio.options.pitch.length > 0) || (foregroundAudio.options.rate && foregroundAudio.options.rate.length > 0) || (foregroundAudio.options.volume && foregroundAudio.options.volume.length > 0));
                                    let voiceOpenTag = `<voice name='${foregroundAudio.options.voice}'>`;
                                    let voiceCloseTag = "</voice>";
                                    if (hasProsodyMod) {
                                        let prosodyOptions = "";
                                        if (foregroundAudio.options.pitch && foregroundAudio.options.pitch.length > 0) {
                                            prosodyOptions += `pitch='${foregroundAudio.options.pitch}'`;
                                        }
                                        if (foregroundAudio.options.rate && foregroundAudio.options.rate.length > 0) {
                                            prosodyOptions += ` rate='${foregroundAudio.options.rate}'`;
                                        }
                                        if (foregroundAudio.options.volume && foregroundAudio.options.volume.length > 0) {
                                            prosodyOptions += ` volume='${foregroundAudio.options.volume}'`;
                                        }
                                        voiceOpenTag += `<prosody ${prosodyOptions}>`;
                                        voiceCloseTag = `</prosody>${voiceCloseTag}`;
                                    }
                                    foregroundSSML += `${voiceOpenTag}${foregroundAudio.content}${voiceCloseTag}`;
                                    prettySSML += `${voiceOpenTag}${foregroundAudio.content}${voiceCloseTag}`;
                                }
                                else {
                                    let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                                    audioBuilder.addPollySequence({ name: foregroundAudio.options.voice, text: foregroundAudio.content, delayMs: foregroundAudio.delay, volume: foregroundAudio.volume, rate: foregroundAudio.options.rate, pitch: foregroundAudio.options.pitch });
                                    let audioUrl = await this.buildAudioBuilder(audioBuilder);
                                    foregroundSSML += `<audio src='${audioUrl}' />`;
                                    prettySSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                }
                            }
                        }
                        else {
                            if (ACEDriver.testing && pollyConfig.enabledInPreview) {
                                let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                                audioBuilder.addPollySequence({ name: 'Amy', text: foregroundAudio.content, volume: foregroundAudio.volume });
                                let audioUrl = await this.buildAudioBuilder(audioBuilder);
                                foregroundSSML += `<audio src='${audioUrl}' />`;
                                prettySSML += ` ${foregroundAudio.content}`;
                            }
                            else {
                                foregroundSSML += ` ${foregroundAudio.content}`;
                                prettySSML += ` ${foregroundAudio.content}`;
                            }
                        }
                    }
                    else {
                        // We are testing, so just return something that will not be valid ssml
                        if (foregroundAudio.type === interfaces_1.AlexaAudioType.AUDIO) {
                            foregroundSSML += `<audio src='${foregroundAudio.content}'/>`;
                            prettySSML += `<audio src='${foregroundAudio.content}'/>`;
                        }
                        else if (foregroundAudio.type === interfaces_1.AlexaAudioType.POLLY) {
                            if (foregroundAudio.options) {
                                foregroundSSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                prettySSML += `<voice name='${foregroundAudio.options.voice}'>${foregroundAudio.content}</voice>`;
                                //                            foregroundSSML += `(POLLY:name=${foregroundAudio.options.voice} text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume} rate=${foregroundAudio.options.rate} pitch=${foregroundAudio.options.pitch})`;
                            }
                            else {
                                foregroundSSML += `(POLLY:name=ERROR_NO_POLLY_NAME_SET text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume})`;
                                prettySSML += `(POLLY:name=ERROR_NO_POLLY_NAME_SET text=${foregroundAudio.content} delayMs=${foregroundAudio.delay} volume=${foregroundAudio.volume})`;
                            }
                        }
                        else {
                            foregroundSSML += ` ${foregroundAudio.content}`;
                            prettySSML += ` ${foregroundAudio.content}`;
                        }
                    }
                }
                let primaryBackgroundAudioItem = undefined;
                for (let backgroundAudio of audioItem.background) {
                    if (backgroundAudio.type === interfaces_1.AlexaAudioType.AUDIO) {
                        // TODO: Loop through and make a whole audio builder out of all the background items
                        // TODO: Right now it only supports one background audio item
                        primaryBackgroundAudioItem = backgroundAudio;
                    }
                }
                // Now combine all of the audio tags if there is background music, otherwise leave them alone. Only works if polly is enabled.
                if (!POLLY_ENABLED || !primaryBackgroundAudioItem) {
                    overallSSML += foregroundSSML;
                }
                else if (primaryBackgroundAudioItem) {
                    if (!ACEDriver.testing || pollyConfig.enabledInPreview) {
                        let foregroundCombinedSSML = await this.combineSSMLAudioTags(foregroundSSML);
                        // Now grab and replace the first URL found in the above and mix it with the background music
                        let srcUrlRegex = /<audio src='([^']*?)'/g;
                        let srcUrlMatch = srcUrlRegex.exec(foregroundCombinedSSML);
                        if (srcUrlMatch && srcUrlMatch[1]) {
                            let foregroundAudioUrl = srcUrlMatch[1];
                            let foregroundDelay = 0;
                            let backgroundDelay = primaryBackgroundAudioItem.delay;
                            if (backgroundDelay < 0) {
                                foregroundDelay += Math.abs(backgroundDelay);
                                backgroundDelay = 0;
                            }
                            let audioBuilder = new AlexaPolly.AlexaAudioBuilder();
                            if (primaryBackgroundAudioItem.options && primaryBackgroundAudioItem.options.blend === interfaces_1.AudioBlendOption.LONGEST) {
                                audioBuilder.trimSetting = "longest";
                            }
                            else {
                                audioBuilder.trimSetting = "first";
                            }
                            audioBuilder.addSFXSequence({ url: foregroundAudioUrl, delayMs: foregroundDelay, volume: 1.0 });
                            audioBuilder.addSFXSequence({ url: primaryBackgroundAudioItem.content, delayMs: backgroundDelay, volume: primaryBackgroundAudioItem.volume });
                            let combinedForegroundBackgroundUrl = await this.buildAudioBuilder(audioBuilder);
                            foregroundCombinedSSML = foregroundCombinedSSML.replace(foregroundAudioUrl, combinedForegroundBackgroundUrl);
                        }
                        overallSSML += foregroundCombinedSSML;
                    }
                    else {
                        overallSSML += foregroundSSML + `(BGM:<audio src='${primaryBackgroundAudioItem.content}' delay='${primaryBackgroundAudioItem.delay}' volume='${primaryBackgroundAudioItem.volume}'/>)`;
                    }
                }
            }
            // Now, run combine audio tags again on the whole entire thing in case there are still more than 5 audio tags across all scenes.
            let overallCombinedSSML;
            if ((!ACEDriver.testing && (AlexaPolly.hasMoreThanFiveAudioTags(overallSSML) || pollyConfig.combineToSingleAudioFile))
                || (ACEDriver.testing && pollyConfig.enabledInPreview)) {
                overallCombinedSSML = await this.combineSSMLAudioTags(overallSSML);
            }
            else {
                overallCombinedSSML = overallSSML;
            }
            return { ssml: overallCombinedSSML, pretty: prettySSML };
        }
        catch (err) {
            throw err;
        }
    }
    /**
     * Get the current story state.
     */
    getCurrentStoryState() {
        return JSON.parse(JSON.stringify(this.storyState)); //deep copy
    }
    getResultOptions() {
        return this.resultOptions;
    }
    /**
     * See if the scene marked as ending, or scene leading to no new choice has been reached as a result of the current resume/run.
     */
    isEndingReached() {
        return StoryStateHelper_1.StoryStateHelper.isEndingReached(this.storyState);
    }
    /**
     * See if a choice was unhandled and allow the caller to do something else if they need to.
     */
    isUnhandledChoice() {
        return this.unhandledChoiceFlag;
    }
    /**
     * Execute the selected choice indicated by the user input.
     */
    async processChoice(userInput) {
        return new Promise(async (resolve, reject) => {
            if (ACEDriver.debug)
                console.log("[DEBUG] Calling processChoice");
            let availableChoices = StoryStateHelper_1.StoryStateHelper.getAvailableChoices(this.storyState);
            if (ACEDriver.debug)
                console.log("[DEBUG] Loading Available Choices: " + JSON.stringify(availableChoices, null, 4));
            let selectedChoice = StoryStateHelper_1.StoryStateHelper.getChoiceByUserInput(this.storyState, userInput, this.locale);
            if (ACEDriver.debug)
                console.log(`[DEBUG] With UserInput=${JSON.stringify(userInput)}, Selected Choice=${JSON.stringify(selectedChoice, null, 4)}`);
            if (selectedChoice == null) {
                if ((!this.storyState.system_prevRecap || this.storyState.system_prevRecap.length == 0)
                    && (!this.storyState.system_prevSpeech || this.storyState.system_prevSpeech.length == 0)) {
                    this.isRepeating = false;
                }
                else {
                    if (this.storyState.system_prevRecap && this.storyState.system_prevRecap.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevRecap);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevRecap);
                    }
                    else if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevSpeech);
                    }
                    if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevRecap);
                    }
                    this.isRepeating = true;
                }
            }
            else {
                StoryStateHelper_1.StoryStateHelper.setSelectedChoiceID(this.storyState, selectedChoice.id);
                let beforeState = JSON.parse(JSON.stringify(this.storyState));
                try {
                    let tempChoiceInstructionAddress = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) + ":" + selectedChoice.id + ":" + -1;
                    this.storyState.system_instruction_mem[tempChoiceInstructionAddress] = selectedChoice.sceneDirections;
                    await this.performInstructions.call(this, tempChoiceInstructionAddress);
                }
                catch (err) {
                    reject(err);
                }
                if (!this.isRepeating) {
                    StoryStateHelper_1.StoryStateHelper.resetAvailableChoices(this.storyState);
                    if (selectedChoice.saveToHistory) {
                        StoryStateHelper_1.StoryStateHelper.addChoiceHistory(this.storyState, selectedChoice, getStateDiffs(beforeState, this.storyState), this.historySize);
                    }
                }
            }
            StoryStateHelper_1.StoryStateHelper.clearSelectedChoiceID(this.storyState);
            resolve();
        });
    }
    /**
     * Process the current scene. Updating speech, reprompt, variables as indicated by the scene.
     */
    async processScene(sceneID, sceneProperty) {
        return new Promise(async (resolve, reject) => {
            if (ACEDriver.debug)
                console.log("[INFO] Calling processScene.");
            let currentSceneID = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
            if (sceneID) {
                currentSceneID = sceneID;
            }
            if (ACEDriver.testing) {
                console.log("\n\nSCENE '" + currentSceneID + "'");
                console.log("........................");
            }
            let currentScene = undefined;
            if (currentSceneID != null) {
                try {
                    currentScene = await this.getSceneByID(currentSceneID || "");
                }
                catch (err) {
                    reject(err);
                }
            }
            if (!currentScene) {
                if (ACEDriver.debug)
                    reject(`[WARN] Cannot find the Scene=[${currentSceneID}]`);
                else
                    resolve();
                return;
            }
            this.stage.startNewScene();
            StoryStateHelper_1.StoryStateHelper.clearRecap(this.storyState);
            for (let variation of currentScene.contents) {
                // evaluate body's conditional
                let conditionPassed = true;
                if (variation.condition && !variation.condition.startsWith("otherwise")) {
                    if (ACEDriver.debug)
                        console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(variation.condition, null, 4));
                    let substitution = substituteSlotValues(variation.condition, this.storyState);
                    if (ACEDriver.debug)
                        console.log("[DEBUG] post-substitution condition= " + JSON.stringify(substitution, null, 4));
                    try {
                        if (!evalInContext(substitution.value, this)) {
                            conditionPassed = false;
                        }
                    }
                    catch (err) {
                        reject(err);
                        return;
                    }
                }
                if (!conditionPassed) {
                    if (ACEDriver.testing && variation.condition)
                        console.log(`${padString("FAILED", 8)}\t>${variation.condition}`);
                    continue;
                }
                if (ACEDriver.testing && variation.condition)
                    console.log(`${padString("PASSED", 8)}\t>${variation.condition}`);
                /*
                 * Narration
                 */
                let sceneNarration = [];
                if (variation.narration) {
                    let narrationText = substituteSlotValues(variation.narration, this.storyState, false).value
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ");
                    let narrationVariations = narrationText.split("||");
                    let selectedNarration = narrationVariations[Math.floor(Math.random() * narrationVariations.length)];
                    sceneNarration = this.buildAudioItemsFromSSML(selectedNarration);
                }
                /*
                 * Scene Directions
                 */
                try {
                    if (variation.sceneDirections && variation.sceneDirections.length > 0) {
                        let instructionSetAddress = currentSceneID + ":" + -1;
                        this.storyState.system_instruction_mem[instructionSetAddress] = (JSON.parse(JSON.stringify(variation.sceneDirections)));
                        await this.performInstructions(instructionSetAddress);
                    }
                }
                catch (err) {
                    throw err;
                }
                if (sceneProperty && sceneProperty.trim().toLowerCase() == "reprompt" && this.stage.getRepromptSceneAudio().foreground.length > 0) {
                    sceneNarration = this.stage.getRepromptSceneAudio().foreground;
                }
                if (sceneProperty && sceneProperty.trim().toLowerCase() == "recap" && this.stage.getRecapSceneAudio().foreground.length > 0) {
                    sceneNarration = this.stage.getRecapSceneAudio().foreground;
                }
                this.stage.appendSceneSpeechForeground(sceneNarration);
                break; // Only one of the scene variations are played.
            }
            this.stage.closeScene();
            resolve();
        });
    }
    /**
     * Peform given list of scene directions in order.
     *
     * @param directions Scene Directions to peform.
     * @return returns the resulting scene direction where all the variables are replaced by the actual values.
     */
    async performInstructions(instructionAddress) {
        if (ACEDriver.debug)
            console.log(`[DEBUG] Calling performSceneDirections...`);
        let isTerminatingDirection = false;
        let visualAlreadyDefined = false;
        let directions = this.storyState.system_instruction_mem[instructionAddress];
        for (let lineNumber = 0; lineNumber < directions.length; lineNumber++) {
            let parameters = JSON.parse(JSON.stringify(directions[lineNumber].parameters));
            let type = directions[lineNumber].directionType;
            for (let paramName of Object.keys(parameters)) {
                if (typeof (parameters[paramName]) == 'string') {
                    if (type !== interfaces_1.SceneDirectionType.REPROMPT && paramName != "condition") {
                        parameters[paramName] = substituteSlotValues(parameters[paramName], this.storyState, false).value;
                    }
                    else {
                        parameters[paramName] = substituteSlotValues(parameters[paramName], this.storyState).value;
                    }
                }
            }
            switch (type) {
                case interfaces_1.SceneDirectionType.CUSTOM: {
                    if (ACEDriver.testing)
                        console.log(`${padString("CUSTOM", 8)}\t> calling custom instruction with:\n${JSON.stringify(parameters, null, 4)}`);
                    for (let extension of this.customExtensions) {
                        if (ACEExtension_1.isInstructionExtension(extension)) {
                            const customInstructionName = parameters.customName;
                            if (extension[customInstructionName]) {
                                await extension[customInstructionName]({
                                    instructionName: parameters.customName,
                                    instructionParameters: parameters,
                                    playStage: this.stage,
                                    storyAccessor: this.storyAccessor,
                                    storyState: this.storyState
                                });
                            }
                        }
                        else {
                            continue;
                        }
                    }
                    break;
                }
                case interfaces_1.SceneDirectionType.SLOT: {
                    let variableName = parameters.variableName;
                    let slotType = parameters.variableType;
                    if (!this.storyState[variableName] || typeof this.storyState[variableName] != 'object') {
                        this.storyState[variableName] = {};
                    }
                    this.storyState[variableName].type = slotType;
                    if (ACEDriver.testing)
                        console.log(`${padString("SLOT", 8)}\t>'${variableName}' as ${slotType}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.BOOKMARK: {
                    let bookmarkName = parameters.variableName;
                    let targetName = parameters.variableValue;
                    if (!targetName) {
                        targetName = StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState);
                    }
                    if (targetName == null) {
                        throw "[ACEDriver Error] target is not defined for the bookmark command.";
                    }
                    this.storyState[bookmarkName] = {
                        type: 'sceneID',
                        value: targetName
                    };
                    if (ACEDriver.testing)
                        console.log(`${padString("BOOKMARK", 8)}\t>'${bookmarkName}' as ${targetName}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.CHOICE: {
                    let choiceID = crypto_1.createHash('md5').update(JSON.stringify(parameters.utterances).trim().toLowerCase()).digest('hex');
                    let choiceInstructions = parameters.directions ? (JSON.parse(JSON.stringify(parameters.directions))) : [];
                    let choice = {
                        id: choiceID,
                        sceneDirections: choiceInstructions,
                        utterances: parameters.utterances,
                        saveToHistory: false //parameters.saveToHistory && parameters.saveToHistory.trim().toLowerCase() == 'true'? true: false
                    };
                    if (parameters.narration) {
                        choice.narration = parameters.narration;
                    }
                    StoryStateHelper_1.StoryStateHelper.enqueueAvailableChoice(this.storyState, choice);
                    if (ACEDriver.testing)
                        console.log(`${padString("CHOICE", 8)}\t> Register ChoiceID=[${choiceID}] for expected input '${parameters.utterances}' for instructions ${JSON.stringify(choiceInstructions, null, 4)}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.CONDITION: {
                    let conditionPassed = true;
                    let conditionString = parameters.condition;
                    if (ACEDriver.debug)
                        console.log("[DEBUG] pre-substitution condition= " + JSON.stringify(conditionString, null, 4));
                    let substitution = substituteSlotValues(conditionString, this.storyState);
                    if (ACEDriver.debug)
                        console.log("[DEBUG] post-substitution condition= " + JSON.stringify(substitution, null, 4));
                    try {
                        if (!evalInContext(substitution.value, this)) {
                            conditionPassed = false;
                        }
                    }
                    catch (err) {
                        throw err;
                    }
                    if (!conditionPassed) {
                        if (ACEDriver.testing && conditionString)
                            console.log(`${padString("FAILED", 8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                    }
                    else {
                        if (ACEDriver.testing && conditionString)
                            console.log(`${padString("PASSED", 8)}\t>'${directions[lineNumber].parameters.condition}' evaluated as [${conditionString}]`);
                        let conditionInstructionAddress = instructionAddress + ":" + lineNumber;
                        if (parameters.directions && parameters.directions.length > 0) {
                            let savingInstructions = (JSON.parse(JSON.stringify(parameters.directions)))
                                .concat(directions.slice(lineNumber + 1));
                            this.storyState.system_instruction_mem[conditionInstructionAddress] = savingInstructions;
                            await this.performInstructions.call(this, conditionInstructionAddress);
                            isTerminatingDirection = true;
                        }
                    }
                    break;
                }
                case interfaces_1.SceneDirectionType.GO_TO: {
                    let destinationPage = parameters.target;
                    if (this.storyState[destinationPage] && this.storyState[destinationPage].type == 'sceneID') {
                        this.playQueue.push({
                            sceneID: this.storyState[destinationPage].value,
                            property: parameters.targetSceneProperty || "narration"
                        });
                    }
                    else {
                        this.playQueue.push({
                            sceneID: destinationPage.toLowerCase(),
                            property: parameters.targetSceneProperty || "narration"
                        });
                    }
                    isTerminatingDirection = true;
                    if (ACEDriver.testing)
                        console.log(`${padString("GO TO", 8)}\t>scene '${destinationPage}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.SAVE_AND_GO: {
                    let destinationPage = parameters.target.toLowerCase();
                    let savingInstructions = directions.slice(lineNumber + 1);
                    let savingAddress = instructionAddress + ":" + lineNumber;
                    this.storyState.system_instruction_mem[savingAddress] = savingInstructions;
                    if (!this.storyState.system_call_stack) {
                        this.storyState.system_call_stack = [];
                    }
                    this.storyState.system_call_stack.push(savingAddress);
                    if (ACEDriver.testing)
                        console.log(`${padString("CALL", 8)}\t>scene '${destinationPage}'`);
                    this.playQueue.push({
                        sceneID: destinationPage,
                        property: parameters.targetSceneProperty || "narration"
                    });
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.RETURN: {
                    if (this.storyState.system_call_stack && this.storyState.system_call_stack.length > 0) {
                        let returnAddress = this.storyState.system_call_stack.splice(-1, 1)[0];
                        if (ACEDriver.testing)
                            console.log(`${padString("RETURN", 8)}\t> Returning to address ${returnAddress}.'`);
                        let poppingSceneID = returnAddress.split(":")[0];
                        StoryStateHelper_1.StoryStateHelper.setCurrentSceneID(this.storyState, poppingSceneID);
                        await this.performInstructions.call(this, returnAddress);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RETURN", 8)}\t> There is instructions to return to.'`);
                    }
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.RESTART: {
                    await this.resetStory();
                    this.playQueue.push({
                        sceneID: interfaces_1.BuiltInScenes.StartScene,
                        property: parameters.targetSceneProperty || "narration"
                    });
                    if (ACEDriver.testing)
                        console.log(`${padString("RESTART", 8)}\t> Refresh and restart the story.`);
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.REPEAT: {
                    if (this.storyState.system_prevSpeech && this.storyState.system_prevSpeech.length > 0) {
                        this.stage.appendStageSpeechAudioSequence(this.storyState.system_prevSpeech);
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);
                        if (ACEDriver.testing)
                            console.log(`${padString("REPEAT", 8)}\t> Repeating previously heard speech:\n${JSON.stringify(this.storyState.system_prevSpeech, null, 4)}\nreprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("REPEAT", 8)}\t> Nothing to repeat.'`);
                    }
                    this.isRepeating = true;
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.REPEAT_REPROMPT: {
                    if (this.storyState.system_prevReprompt && this.storyState.system_prevReprompt.length > 0) {
                        this.stage.setStageSpeechAudioSequence(this.stage.getStageRepromptAudioSequence().concat(this.storyState.system_prevReprompt));
                        this.stage.appendStageRepromptAudioSequence(this.storyState.system_prevReprompt);
                        if (ACEDriver.testing)
                            console.log(`${padString("RE-REPROMPT", 8)}\t> Repeating previously heard reprompt:\n${JSON.stringify(this.storyState.system_prevReprompt, null, 4)}`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RE-REPROMPT", 8)}\t> Nothing to reprompt.'`);
                    }
                    this.isRepeating = true;
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.BACK: {
                    let countBack = parameters.count + 1;
                    if (!this.storyState.system_originStack || this.storyState.system_originStack.length == 0) {
                        if (ACEDriver.testing)
                            console.log(`${padString("BACK", 8)}\t>There is no scene to go back to.`);
                    }
                    else {
                        let transitionStack = JSON.parse(JSON.stringify(this.storyState.system_originStack));
                        let destinationScene = undefined;
                        while (countBack-- > 0 && transitionStack.length > 0) {
                            destinationScene = transitionStack.splice(-1, 1)[0];
                        }
                        this.playQueue.push(destinationScene);
                        this.storyState.system_originStack = transitionStack;
                        if (ACEDriver.testing)
                            console.log(`${padString("BACK", 8)}\t> back count=${parameters.count} to scene '${JSON.stringify(destinationScene)}'`);
                    }
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.RECAP: {
                    let recapMessage = substituteSlotValues(parameters.message, this.storyState, false).value
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ")
                        .split("||");
                    let selectedRecap = recapMessage[Math.floor(Math.random() * recapMessage.length)];
                    if (selectedRecap.trim().length > 0) {
                        this.stage.appendSceneRecapForeground(this.buildAudioItemsFromSSML(selectedRecap.replace(/\n/g, ' ').replace(/[\s]+/g, ' ')));
                        if (ACEDriver.testing)
                            console.log(`${padString("RECAP", 8)}\t>'${selectedRecap}'`);
                    }
                    else {
                        if (ACEDriver.testing)
                            console.log(`${padString("RECAP", 8)}\t>'Nothing to set as recap message.'`);
                    }
                    break;
                }
                case interfaces_1.SceneDirectionType.END: {
                    StoryStateHelper_1.StoryStateHelper.setEndingReached(this.storyState, true);
                    await this.resetStory();
                    this.isRepeating = true;
                    if (ACEDriver.testing)
                        console.log(`END`);
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.PAUSE: {
                    this.isPausing = true;
                    if (ACEDriver.testing)
                        console.log(`PAUSE`);
                    isTerminatingDirection = true;
                    break;
                }
                case interfaces_1.SceneDirectionType.BGM: {
                    let bgmURL = parameters.audioURL;
                    this.stage.appendSceneSpeechBackground(this.buildAudioItemsFromSSML(`<audio src='${bgmURL}' delay='${parameters.delayMs || ""}' volume='${parameters.volume || ""}' blend='${parameters.blend}'/>`));
                    if (ACEDriver.testing)
                        console.log(`${padString("BGM", 8)}\t>${bgmURL}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.CLEAR: {
                    let attributeName = parameters.variableName;
                    if (attributeName.trim() == "*") {
                        attributeName = "";
                        for (let key of Object.keys(this.storyState)) {
                            if (!key.startsWith("system_")) {
                                attributeName += `${key} ; `;
                                delete this.storyState[key];
                            }
                        }
                    }
                    else {
                        delete this.storyState[attributeName];
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("CLEAR", 8)}\t>'${attributeName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.ADD_TO_INVENTORY: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    if (!this.storyState[listName]) {
                        this.storyState[listName] = {};
                    }
                    if (!this.storyState[listName][item]) {
                        this.storyState[listName][item] = 0;
                    }
                    this.storyState[listName][item]++;
                    if (ACEDriver.testing)
                        console.log(`${padString("ADD INVENTORY", 8)}\t>'${item}' to '${listName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.ADD_ITEM: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    let sizeLimit = parameters.size || "-1";
                    if (!this.storyState[listName]) {
                        this.storyState[listName] = [];
                    }
                    this.storyState[listName].push(item);
                    let size = parseInt(sizeLimit, 10);
                    if (size > 0 && this.storyState[listName].length > size) {
                        this.storyState[listName].splice(0, this.storyState[listName].length - size);
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("ADD ITEM", 8)}\t>'${item}' to '${listName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.GET_TIME: {
                    let currentTime = new Date().getTime();
                    this.storyState.system_return = currentTime;
                    if (ACEDriver.testing)
                        console.log(`${padString("GET TIME", 8)}\t>${currentTime}`);
                }
                case interfaces_1.SceneDirectionType.REMOVE_ITEM: {
                    let item = parameters.itemName;
                    let listName = parameters.variableName;
                    if (this.storyState[listName] && typeof this.storyState[listName].length == 'number') {
                        let deletingIndex = -1;
                        for (let i = 0; i < this.storyState[listName].length; i++) {
                            if (this.storyState[listName][i] == item) {
                                deletingIndex = i;
                                break;
                            }
                        }
                        if (deletingIndex >= 0) {
                            let removeResult = this.storyState[listName].splice(deletingIndex, 1)[0];
                            this.storyState.system_return = removeResult;
                        }
                    }
                    else if (this.storyState[listName] && typeof this.storyState[listName].length == 'undefined') {
                        if (typeof this.storyState[listName][item] == 'number' && this.storyState[listName][item] > 0) {
                            this.storyState[listName][item]--;
                        }
                        else if (typeof this.storyState[listName][item] != 'number') {
                            delete this.storyState[listName][item];
                        }
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>'${item}' from '${listName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.REMOVE_FIRST: {
                    let listName = parameters.variableName;
                    if (this.storyState[listName]) {
                        let removeResult = this.storyState[listName].splice(0, 1)[0];
                        this.storyState.system_return = removeResult;
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>FIRST from '${listName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.REMOVE_LAST: {
                    let listName = parameters.variableName;
                    if (this.storyState[listName]) {
                        let removeResult = this.storyState[listName].splice(this.storyState[listName].length - 1, 1);
                        this.storyState.system_return = removeResult;
                    }
                    if (ACEDriver.testing)
                        console.log(`${padString("DEL ITEM", 8)}\t>LAST from '${listName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.FLAG: {
                    let variableName = parameters.variableName;
                    this.storyState[variableName] = true;
                    if (ACEDriver.testing)
                        console.log(`${padString("FLAG", 8)}\t>'${variableName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.UNFLAG: {
                    let variableName = parameters.variableName;
                    this.storyState[variableName] = false;
                    if (ACEDriver.testing)
                        console.log(`${padString("UNFLAG", 8)}\t>'${variableName}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.SET: {
                    let variableName = parameters.variableName;
                    let value = parameters.variableValue == "undefined" ? 0 : parseFloat(parameters.variableValue);
                    if (parameters.variableValue.length === 0) {
                        value = "";
                    }
                    else if (isNaN(parameters.variableValue)) {
                        value = parameters.variableValue;
                        if (value == 'true') {
                            value = true;
                        }
                        else if (value == 'false') {
                            value = false;
                        }
                    }
                    if (this.storyState[variableName] == undefined) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = value;
                    if (ACEDriver.testing)
                        console.log(`${padString("SET", 8)}\t>'${variableName}' as ${value}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.REDUCE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) - value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("REDUCE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.INCREASE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) + value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("INCREASE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.MULTIPLY: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) * value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("MULTIPLY", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.DIVIDE: {
                    let variableName = parameters.variableName;
                    let value = parseFloat(parameters.variableValue);
                    if (isNaN(parameters.variableValue)) {
                        value = 0;
                    }
                    if (isNaN(this.storyState[variableName])) {
                        this.storyState[variableName] = 0;
                    }
                    this.storyState[variableName] = Math.round((parseFloat(this.storyState[variableName]) / value) * 100) / 100;
                    if (ACEDriver.testing)
                        console.log(`${padString("DIVIDE", 8)}\t>'${variableName}' by ${value} = ${this.storyState[variableName]}`);
                    break;
                }
                case interfaces_1.SceneDirectionType.ROLL: {
                    let rollEval = parameters.diceString;
                    this.evaluateDiceRoll(rollEval);
                    if (ACEDriver.testing)
                        console.log(`${padString("ROLL", 8)}\t>'${rollEval}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.REPROMPT: {
                    let repromptMessages = substituteSlotValues(parameters.message, this.storyState, false).value
                        .replace(/\n/g, " ")
                        .replace(/[\s]+/g, " ")
                        .split("||");
                    let selectedReprompt = repromptMessages[Math.floor(Math.random() * repromptMessages.length)];
                    this.stage.appendSceneRepromptForeground(this.buildAudioItemsFromSSML(selectedReprompt.replace(/\n/g, ' ').replace(/[\s]+/g, ' ')));
                    if (ACEDriver.testing)
                        console.log(`${padString("REPROMPT", 8)}\t>'${selectedReprompt}'`);
                    break;
                }
                case interfaces_1.SceneDirectionType.VISUALS: {
                    if (visualAlreadyDefined) {
                        let currentVisuals = this.stage.getStageVisualOptions() || [];
                        currentVisuals[currentVisuals.length - 1] = parameters;
                        this.stage.setStageVisualOptions(currentVisuals);
                    }
                    else {
                        visualAlreadyDefined = true;
                        this.stage.appendStageVisuals(parameters);
                    }
                    break;
                }
                default: {
                    throw "[STORY - SYNTAX ERROR] the story effect is not recognized.\nline number=["
                        + lineNumber + "]\nline content=["
                        + JSON.stringify(directions[lineNumber], null, 4) + "]\n"
                        + "pageID=[" + StoryStateHelper_1.StoryStateHelper.getCurrentSceneID(this.storyState) + "]";
                }
            }
            if (isTerminatingDirection || lineNumber == directions.length - 1) {
                delete this.storyState.system_instruction_mem[instructionAddress];
                break;
            }
        }
        return isTerminatingDirection;
    }
    /**
     * Get the scene object of the currently driving story givene the scene ID.
     * @param sceneID scene ID
     */
    async getSceneByID(sceneID) {
        let adjustedSceneID = sceneID.trim().toLowerCase();
        let drivingStoryID = await this.storyAccessor.getStoryID();
        if (!ACEDriver.STORY_METADATA_CACHE[drivingStoryID]) {
            let id2Page = {};
            for (let scene of await this.storyAccessor.getAllScenes()) {
                id2Page[scene.id.toLowerCase()] = scene;
            }
            ACEDriver.STORY_METADATA_CACHE[drivingStoryID] = id2Page;
        }
        if (ACEDriver.STORY_METADATA_CACHE[drivingStoryID][adjustedSceneID] || interfaces_1.BuiltInScenes.PauseScene.toLowerCase() == adjustedSceneID ||
            interfaces_1.BuiltInScenes.ResumeScene.toLowerCase() == adjustedSceneID) {
            return ACEDriver.STORY_METADATA_CACHE[drivingStoryID][adjustedSceneID];
        }
        else {
            throw `[ERROR] Cannot find the scene ${adjustedSceneID} from the story=${drivingStoryID}.`;
        }
    }
    clearMetadataCache() {
        ACEDriver.STORY_METADATA_CACHE = {};
    }
    /**
     * Compute a dice roll given a standard dice string.
     *
     * @param diceString
     */
    evaluateDiceRoll(diceString) {
        let diceRegex = /([\d])d([\d]*)+[k]?([\d]*)/gi;
        let diceMatch = diceRegex.exec(diceString);
        let rollResults = [];
        while (diceMatch != null) {
            let rollResult = 0;
            let diceCount = parseInt(diceMatch[1], 10);
            let faceCount = parseInt(diceMatch[2], 10);
            let selectCount = parseInt(diceMatch[3], 10);
            let rolls = [];
            for (let i = 0; i < diceCount; i++) {
                if (ACEDriver.probabilityOff) {
                    rolls.push((faceCount + 1) / 2);
                }
                else {
                    rolls.push(Math.floor(Math.random() * faceCount) + 1);
                }
            }
            let sumCount = rolls.length;
            if (selectCount) {
                rolls.sort().reverse(); //descending sort
                sumCount = selectCount;
            }
            for (let i = 0; i < sumCount; i++) {
                rollResult += rolls[i];
            }
            rollResults.push(rollResult);
            diceMatch = diceRegex.exec(diceString);
        }
        let diceMatchReplace = diceString.replace(diceRegex, () => {
            return String(rollResults.splice(0, 1)[0]);
        });
        let rollFinalEval = eval(diceMatchReplace);
        if (ACEDriver.debug)
            console.log("[DEBUG] Roll result for the entire dice configuration=[" + diceMatchReplace + "], result=[" + rollFinalEval + "]");
        this.storyState.rollResult = rollFinalEval;
    }
    /**
     * Given a string of ssml (supported with voice, audio tags), create an array of Audio Items.
     * @param ssml string of ssml text
     */
    buildAudioItemsFromSSML(ssml) {
        let dialogue = ssml.trim();
        let partitioningRegex = /(<audio[\s]+src=[\"'][^><]+?[\"'][\s]*?\/>)|(<voice[\s]+[\s\S]+?<\/voice>)|([\s\S]+?)(?=<audio|<voice|$)/g;
        let partitionMatch = partitioningRegex.exec(dialogue);
        let audioItems = [];
        while (partitionMatch != null) {
            if (partitionMatch[1] && partitionMatch[1].trim().length > 0) {
                let audioTagParse = /\b(src|volume|delay|blend)=[\"']([\S]+?)[\"']/g;
                let audioTagText = partitionMatch[1];
                let audioTagMatch = audioTagParse.exec(audioTagText);
                let volume = 1.0;
                let delay = 0;
                let content = "";
                let blendOption = interfaces_1.AudioBlendOption.TRIM;
                while (audioTagMatch != null) {
                    if (!audioTagMatch[2] || audioTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    }
                    else if (audioTagMatch[1].trim() == "src") {
                        content = audioTagMatch[2];
                    }
                    else if (audioTagMatch[1].trim() == "volume") {
                        volume = parseFloat(audioTagMatch[2]);
                    }
                    else if (audioTagMatch[1].trim() == "delay") {
                        delay = parseInt(audioTagMatch[2]);
                    }
                    else if (audioTagMatch[1].trim() == "blend") {
                        blendOption = audioTagMatch[2];
                    }
                    audioTagMatch = audioTagParse.exec(audioTagText);
                }
                audioItems.push({
                    type: interfaces_1.AlexaAudioType.AUDIO,
                    content: content,
                    volume: volume,
                    delay: delay,
                    options: {
                        blend: blendOption
                    }
                });
            }
            else if (partitionMatch[2] && partitionMatch[2].trim().length > 0) {
                let pollyTagParse = /<voice[\s]+[\s\S]*?(name|volume|delay|pitch|rate)=[\"']([\S]+?)[\"'][\s\S]*?>/g;
                let pollyTagText = partitionMatch[2];
                let pollyTagMatch = pollyTagParse.exec(pollyTagText);
                let name = "";
                let volume = 3.0;
                let delay = 0;
                let rate = "";
                let pitch = "";
                while (pollyTagMatch != null) {
                    if (!pollyTagMatch[2] || pollyTagMatch[2].trim().length <= 0) {
                        // skip for no attribute value
                    }
                    else if (pollyTagMatch[1].trim() == "name") {
                        name = pollyTagMatch[2];
                    }
                    else if (pollyTagMatch[1].trim() == "volume") {
                        volume = parseFloat(pollyTagMatch[2]);
                    }
                    else if (pollyTagMatch[1].trim() == "delay") {
                        delay = parseInt(pollyTagMatch[2]);
                    }
                    else if (pollyTagMatch[1].trim() == "pitch") {
                        pitch = pollyTagMatch[2];
                    }
                    else if (pollyTagMatch[1].trim() == "rate") {
                        rate = pollyTagMatch[2];
                    }
                    pollyTagMatch = pollyTagParse.exec(pollyTagText);
                }
                let contentMatch = />([\s\S]*?)<\/voice/g.exec(pollyTagText);
                audioItems.push({
                    type: interfaces_1.AlexaAudioType.POLLY,
                    content: contentMatch[1],
                    volume: volume,
                    delay: delay,
                    options: {
                        pitch: pitch,
                        rate: rate,
                        voice: name
                    }
                });
            }
            else if (this.isPollyAsDefault) {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: interfaces_1.AlexaAudioType.POLLY,
                        content: partitionMatch[3],
                        volume: this.volume,
                        delay: 0,
                        options: {
                            pitch: this.pitch,
                            rate: this.rate,
                            voice: this.voiceName
                        }
                    });
                }
            }
            else {
                if (partitionMatch[3].trim().length > 0) {
                    audioItems.push({
                        type: interfaces_1.AlexaAudioType.TEXT,
                        content: partitionMatch[3],
                        volume: 3.0,
                        delay: 0
                    });
                }
            }
            partitionMatch = partitioningRegex.exec(dialogue);
        }
        return audioItems;
    }
}
ACEDriver.STORY_METADATA_CACHE = {};
ACEDriver.debug = false;
ACEDriver.testing = false;
/**
 * flag this variable to alway run the average value for dice rolls.
 */
ACEDriver.probabilityOff = false;
exports.ACEDriver = ACEDriver;
function substituteSlotValues(line, eventParams, isCondition = true) {
    // Now substitute in all the {variable1}, {variable2}, etc. fields
    let regex = /\{([^{}]*?)\}/g;
    let matches = line.match(regex);
    let allSlotsFilled = true;
    while (matches) {
        let slotsToFill = {};
        // Find all the replacement slot names
        for (const match of matches) {
            slotsToFill[match] = 1;
        }
        let keys = Object.keys(slotsToFill);
        for (let keyOriginal of keys) {
            // Remove the opening and closing { } signs and single quotes within the key
            let key = keyOriginal.substr(1, keyOriginal.length - 2).replace(/\'/g, "");
            line = line.replace(new RegExp("\\{" + keyOriginal.substr(1, keyOriginal.length - 2) + "\\}", "g"), "{" + key + "}");
            if (key.split(".").length > 1) {
                let splitKey = key.split(".");
                let crawl = eventParams[splitKey[0].replace(/'/g, "")];
                for (let i = 1; i < splitKey.length; i++) {
                    if (crawl != undefined) {
                        crawl = crawl[splitKey[i]];
                        if (crawl != undefined && i == splitKey.length - 1) {
                            let find = "\\{" + key + "\\}";
                            let re = new RegExp(find, 'g');
                            let value = crawl;
                            line = line.replace(re, value);
                        }
                        if (crawl == undefined) {
                            let find = "\\{" + key + "\\}";
                            let re = new RegExp(find, 'g');
                            let value = crawl;
                            line = line.replace(re, "undefined");
                        }
                    }
                    else {
                        let find = "\\{" + key + "\\}";
                        let re = new RegExp(find, 'g');
                        line = line.replace(re, "false");
                        allSlotsFilled = true;
                    }
                }
            }
            else {
                if (eventParams[key.replace(/'/g, "")] != undefined) {
                    let find = "\\{" + key + "\\}";
                    let re = new RegExp(find, 'g');
                    let value = eventParams[key.replace(/'/g, "")];
                    if (isNaN(value) && isCondition) {
                        value = "'" + value + "'";
                    }
                    line = line.replace(re, value);
                }
                else {
                    let find = "\\{" + key + "\\}";
                    let re = new RegExp(find, 'g');
                    line = line.replace(re, "false");
                    allSlotsFilled = true;
                }
            }
        }
        matches = line.match(regex);
    }
    return { value: line, allSlotsFilled: allSlotsFilled };
}
// Evalute the given string given the limited context given
function evalInContext(js, context) {
    //# Return the results of the in-line anonymous function we .call with the passed context
    return function () { return eval(js.replace(/\bundefined\b/g, "false")); }.call(context);
}
/*
`
<prosody rate="${rate}" pitch="${pitch}">
<amazon:effect name="drc" vocal-tract-length="+0%">
<amazon:auto-breaths>
${partitionMatch[0]}
</amazon:auto-breaths>
</amazon:effect>
</prosody>

audioBuilder.addPollySequence({name: voiceName, text: textWithVoiceMarkup, delayMs: 100, volume: volume});
let outputUrl = await buildAudio(audioBuilder);

resultDialogue += AlexaUtil.wrapAudioTag(outputUrl);
`*/
function check(pre, before, after) {
    let padSize = process.env.ABC_DEBUG_PAD_SIZE || 20;
    if ((before === undefined && after !== undefined) || (before !== undefined && after === undefined)) {
        console.log(`[${padString(pre, padSize)}\t|\t${padString(JSON.stringify(before), padSize)}\t>>>\t${padString(JSON.stringify(after), padSize)}]`);
        return;
    }
    if (after == undefined || after == null) {
        return;
    }
    for (let key of Object.keys(after)) {
        if (typeof after[key] === "object") {
            check(pre + "." + key, before[key], after[key]);
        }
        else {
            if (before[key] !== after[key]) {
                if (pre.length > 0) {
                    console.log(`[${padString(pre + "." + key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                }
                else {
                    console.log(`[${padString(key, padSize)}\t|\t${padString(before[key], padSize)}\t>>>\t${padString(after[key], padSize)}]`);
                }
            }
        }
    }
    return;
}
function getStateDiffs(before, after) {
    let stateDiffs = [];
    // check removed items
    for (let key of Object.keys(before)) {
        if (before[key] && after[key] === undefined) {
            stateDiffs.push({
                itemName: key,
                beforeValue: JSON.parse(JSON.stringify(before[key])),
                afterValue: undefined
            });
        }
    }
    for (let key of Object.keys(after)) {
        if (JSON.stringify(after[key]) != JSON.stringify(before[key])) {
            stateDiffs.push({
                itemName: key,
                beforeValue: before[key] ? JSON.parse(JSON.stringify(before[key])) : undefined,
                afterValue: JSON.parse(JSON.stringify(after[key]))
            });
        }
    }
    return stateDiffs;
}
function padString(incomingText, length) {
    let text = String(incomingText);
    let result = text;
    if (text.length < length) {
        for (let i = 0; i <= length - text.length; i++) {
            result += " ";
        }
    }
    else {
        result = "~" + result.substring(text.length - length);
    }
    return result;
}
//# sourceMappingURL=driver.js.map