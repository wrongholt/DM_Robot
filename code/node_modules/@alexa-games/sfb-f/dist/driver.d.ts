import { UserInput, StoryMetadata, ABCImportPlugin, Scene, SceneAudioItem, VisualOptions, ResultOption } from './aceEntities/interfaces';
import { InstructionExtension, ImporterExtension, DriverExtension } from './extensions/ACEExtension';
declare type ACEExtensionType = ImporterExtension | DriverExtension | InstructionExtension;
export declare class ACEDriver {
    private static STORY_METADATA_CACHE;
    static debug: boolean;
    static testing: boolean;
    /**
     * flag this variable to alway run the average value for dice rolls.
     */
    static probabilityOff: boolean;
    private isPollyAsDefault;
    private importHandlersByType;
    private customExtensions;
    private resultOptions;
    private storyState;
    private storyAccessor;
    private stage;
    private playQueue;
    private unhandledChoiceFlag;
    private isPausing;
    private isRepeating;
    private locale;
    voiceName: string;
    pitch: string;
    rate: string;
    volume: number;
    historySize: number;
    constructor(storyMetadata: StoryMetadata, customImportPlugins?: ABCImportPlugin[], extensions?: ACEExtensionType[], pollyConfiguration?: any, locale?: string);
    /**
     * invoke before calling resumeStory if the story history and progress needs to be reset by running the start sequence.
     * onStart implementation of all registered extensions are run.
     *
     * @param startingStoryState
     */
    resetStory(startingStoryState?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Resume the story.
     * If story has been paused, run the resume cycle by playing the 'Resume' scene first.
     * Otherwise, Run normally from the bookmarked scene ID.
     *
     * @param userInput
     * @param startingStoryState
     */
    resumeStory(_userInput: UserInput, startingStoryState?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Run the pause sequence by playing the 'Pause' scene.
     *
     * @param startingStoryState
     */
    pauseStory(_userInput: UserInput, startingStoryState?: {
        [key: string]: any;
    }): Promise<void>;
    /**
     * Undo a choice.
     */
    undoLastChoice(storyState: {
        [key: string]: any;
    }): Promise<void>;
    enqueueNextSceneID(nextSceneID: string): Promise<void>;
    /**
     * Configure the default polly narrator settings.
     * @param voiceName
     * @param pitch
     * @param rate
     * @param volume
     */
    configureDefaultPollyNarrator(voiceName: string, pitch: string, rate: string, volume: number): void;
    /**
     * Turning on the 'default polly' causes all narration texts (including the ones not surrounded by the 'voice' tag) to be read in polly voice.
     * The polly voice setting for this can be configured by calling configureDefaultPollyNarrator().
     */
    turnOnDefaultPolly(): void;
    /**
     * Turning off the 'default polly' causes all narration texts (texts NOT surrounded by the 'voice' tag) to be processed as non-polly voice.
     */
    turnOffDefaultPolly(): void;
    buildAudioBuilder(audioBuilder: any): Promise<string>;
    combineSSMLAudioTags(ssmlIn: string): Promise<string>;
    getSpeechSSMLText(): Promise<string>;
    getSpeechSSMLAndPrettyText(): Promise<{
        ssml: string;
        pretty: string;
    }>;
    getRepromptSSMLText(): Promise<string>;
    getRepromptSSMLAndPrettyText(): Promise<{
        ssml: string;
        pretty: string;
    }>;
    getVisuals(): Promise<VisualOptions[] | undefined>;
    buildAudioScenes(sceneAudioItemList: SceneAudioItem[]): Promise<{
        ssml: string;
        pretty: string;
    }>;
    /**
     * Get the current story state.
     */
    getCurrentStoryState(): {
        [key: string]: any;
    };
    getResultOptions(): ResultOption[];
    /**
     * See if the scene marked as ending, or scene leading to no new choice has been reached as a result of the current resume/run.
     */
    isEndingReached(): boolean;
    /**
     * See if a choice was unhandled and allow the caller to do something else if they need to.
     */
    isUnhandledChoice(): boolean;
    /**
     * Execute the selected choice indicated by the user input.
     */
    processChoice(userInput: UserInput): Promise<any>;
    /**
     * Process the current scene. Updating speech, reprompt, variables as indicated by the scene.
     */
    private processScene;
    /**
     * Peform given list of scene directions in order.
     *
     * @param directions Scene Directions to peform.
     * @return returns the resulting scene direction where all the variables are replaced by the actual values.
     */
    performInstructions(instructionAddress: string): Promise<boolean>;
    /**
     * Get the scene object of the currently driving story givene the scene ID.
     * @param sceneID scene ID
     */
    getSceneByID(sceneID: string): Promise<Scene>;
    clearMetadataCache(): void;
    /**
     * Compute a dice roll given a standard dice string.
     *
     * @param diceString
     */
    private evaluateDiceRoll;
    /**
     * Given a string of ssml (supported with voice, audio tags), create an array of Audio Items.
     * @param ssml string of ssml text
     */
    private buildAudioItemsFromSSML;
}
export {};
